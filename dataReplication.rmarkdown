---
title: "dataReplication"
format: html
editor: visual
toc: true
toc-expand: 3
toc-title: Contents
---



# Data Replication Project: Replicating a Social Network Analysis

[**Based on: Blaszczyk, M. B. (2018). Consistency in social network position over changing environments in a seasonally breeding primate. *Behavioral Ecology and Sociobiology*, *72*(1), 11. <https://doi.org/10.1007/s00265-017-2425-y>**]{.underline}

## Background

### Aims

The original study cited above aimed to investigate the consistency of social behavior in wild vervet monkeys (*Chlorocubus pygerthrus*) across three seasons, the breeding season, winter season, and birthing season. Blaszczyk created grooming networks for each season and measured the repeatability of seven network metrics (In-/Out-degree, In-/Out-strength, betweenness, eigenvector centrality, and clustering coefficient) along with the effects of sex and dominance rank on these metrics.

### Data Used

Blaszczyk used 20-minute continuous focal sampling to record grooming bouts lasting at least 5 seconds. The final data included who groomed and who was groomed, how long the grooming bout lasted, the total number of minutes the actor and receiver were seen, the total amount of time in seconds the same dyad was seen together, and grooming rate (grooming bout time/time dyad seen together). A different dataset was used for each season, resulting in three unique datasets characterizing grooming dyads for the group under study. Additionally, individuals' IDs, sex, and elo rating for each season was stored in a fourth dataset.

### Analysis

The initial analysis used function in the {igraph} package to construct grooming networks for each season. These networks were one directed and weighted based on grooming rate. {igraph} as also used to calculate the seven network metrics. Elo-ratings were calculated using the {EloRating} package and converted to ranks on the last day of each season (IDs_Sex_EloScores in OGData).

To test the repeatability of each metric across seasons, linear mixed effects models (LMMs) were run using the {rptR} package. Models were run for the whole mixed sex sample (n = 26), females (n = 16), and males (n = 10) with season being a random effect. These models were also all run again with rank included as a fixed effect, resulting in a total of 5 repeatability models run for each metric (35 total models).

Additionally, sex was used as a fixed effect for (G)LMMs to examine the effects of sex differences on network metrics. (G)LMMs were also run with rank as a fixed effect for each sex separately to determing the effects of dominance rank on all social network metrics.

Node-based permutation tests with 1000 iterations were used on all models to calculate p-values to determine the significance of the repeatability estimates from the rpt() models and the signifiance of sex and rank differences in the (G)LMMs. In order to test for the collinearity between each pair of metrics, Spearman rank correlation was used. All mixed models were fit with the {lme4} package.

### Conclusions

Blaszczyk found that, based on the repeatability of each network metric, vervet monkey social network position was consistent over the three seasons. Grooming in-strength, out-strength, eigenvector centrality, and in-degree were the most repeatable for both sexes. Betweenness showed no consistency across seasons for both sexes. Only males were consistent in out-degree and clustering coefficients.

## Replication

I will be replicating the calculations of the network metrics, the visualizations of the social networks per season, the visualizations of the network metrics across seasons, the repeatability estimates of each network, the node-based permutations of each metric, the spearmans rank correlation of the network metrics, and the models of the effects of rank and sex on network metrics.

## Tools

First, we will load in the libraries with the functions we need to conduct the analysis



```{r}
#| message: false
#| warning: false
library(tidyverse)
library(igraph)
library(rptR)
library(lme4)
library(ggplot2)
library(cowplot)
library(mosaic)
library(rstatix)
```



## Data

Next, we will load in the data using the raw links provided by github. Each of these files can be found in the github repository. The elo variable will hold the data with demographic details and elo rating, s1 will hold all the season 1 data, s2 will hold the season 2 data, and s3 will hold the season 3 data.



```{r}
#| message: false
#| warning: false
f <- "https://raw.githubusercontent.com/NicoJaws23/dataReplication/refs/heads/main/IDs_Sex_EloScores.csv"
elo <- read_csv(f)
head(elo)

f1 <- "https://raw.githubusercontent.com/NicoJaws23/dataReplication/refs/heads/main/GroomDyads_S1.csv"
s1 <- read_csv(f1)
head(s1)

f2 <- "https://raw.githubusercontent.com/NicoJaws23/dataReplication/refs/heads/main/GroomDyads_S2.csv"
s2 <- read_csv(f2)
head(s2)

f3 <- "https://raw.githubusercontent.com/NicoJaws23/dataReplication/refs/heads/main/GroomDyads_S3.csv"
s3 <- read_csv(f3)
head(s3)
```



## Adjustments

Next, we will make some adjustments to the original data. Considering that the analysis uses season as a random effect, we ill add a column which holds a value for the corresponding season. We will also have a name for the season held in another column along with columns which convert the groom time and dyad time to minutes. Finally, we will combine all the data into one data frame.



```{r}
#| message: false
#| warning: false
s1 <- mutate(s1, Season = 1, sType = "Mating", groomMin = total.groom.secs/60, dyadObsMin = dyad.obs.secs/60)
s2 <- mutate(s2, Season = 2, sType = "Winter", groomMin = total.groom.secs/60, dyadObsMin = dyad.obs.secs/60)
s3 <- mutate(s3, Season = 3, sType = "Birth", groomMin = total.groom.secs/60, dyadObsMin = dyad.obs.secs/60)

#Combine all 3 seasons into one big table
com <- bind_rows(list(s1, s2, s3))

```



## Network Plots

Now will will plot each seasons social network. First, we need to define the edges for each network which we will store in a variable names sXEdges. This will be a data frame with the actor, recipient, and grooming rate. Next we will graph the social network using the graph_from_data_frame() function which will take out edges data as an argument along with setting directed to TRUE. In the original study, females are white circles while males are gray circles. To do this, we will call the colors of the vertices of the graph and set them to be based on vertices name which is based on each individuals ID. This will be linked to the elo table which has the sex of each individual which be used to assign the proper color to each vertex using an if_else() statement. Additionally, node size was based on a scaled unweighted degree which we will calulate using the degree() function from {igraph}. This will cause each node to be sized based on the degree of the grooming rate, with those recieving more being larger than those who recieved less. Then, using the plot.igraph() function, we will plot the social network. This will be repeated for each season. I was not able to figure out how to combine all three figures into one nice row, but it is meant to represent figure 1.

### Season 1



```{r}
#| message: false
#| warning: false
s1Edges <- data.frame(from = s1$"Actor", to = s1$"Recip", weight = s1$groom.rate)
s1G <- graph_from_data_frame(d = s1Edges, directed = TRUE)
nsize1 <- 5 + 15*(degree(s1G)/max(degree(s1G)))

V(s1G)$color <- sapply(V(s1G)$name, function(name) {
  row <- which(elo$ID == name)
  if(elo$Sex[row] == "F") {
    "white"
  } else {
    "gray"
  }
})

s1p <- plot.igraph(s1G, 
            vertex.shape = "circle",
            vertex.size = nsize1,
            vertex.color = V(s1G)$color,
            vertex.label = "",
            edge.arrow.size = 0.3,
            edge.curved = .5,
            main = c("Season 1",
            "March - May",
            "FOH = 497", " ND = 0.45"))
```



### Season 2



```{r}
#| message: false
#| warning: false
s2Edges <- data.frame(from = s2$"Actor", to = s2$"Recip", weight = s2$groom.rate)
s2G <- graph_from_data_frame(d = s2Edges, directed = TRUE)
nsize2 <- 5 + 15*(degree(s2G)/max(degree(s2G)))

V(s2G)$color <- sapply(V(s2G)$name, function(name) {
  row <- which(elo$ID == name)
  if(elo$Sex[row] == "F") {
    "white"
  } else {
    "gray"
  }
})

s2p <- plot.igraph(s2G, 
            vertex.shape = "circle",
            vertex.size = nsize2,
            vertex.color = V(s1G)$color,
            vertex.label = "",
            edge.curved = .75,
            edge.arrow.size = 0.3,
            main = c("Season 2",
            "June - September",
            "FOH = 967.1", " ND = 0.71"))
```



### Season 3



```{r}
#| message: false
#| warning: false
s3Edges <- data.frame(from = s3$"Actor", to = s3$"Recip", weight = s3$groom.rate)
s3G <- graph_from_data_frame(d = s3Edges, directed = TRUE)
nsize3 <- 5 + 15*(degree(s3G)/max(degree(s3G)))

V(s3G)$color <- sapply(V(s3G)$name, function(name) {
  row <- which(elo$ID == name)
  if(elo$Sex[row] == "F") {
    "white"
  } else {
    "gray"
  }
})

s3p <- plot.igraph(s3G, 
            vertex.shape = "circle",
            vertex.size = nsize3,
            vertex.color = V(s1G)$color,
            vertex.label = "",
            edge.curved = .75,
            edge.arrow.size = 0.3,
            main = c("Season 3",
            "October - December",
            "FOH = 705.2", " ND = 0.52"))
```



My networks closely approximate those in the original study in Figure 1

![](Images/Figure1.png)

## Calculating Metrics

Next, we will calculate the each of the 7 metrics used in the study, in-degree, out-degree, in-strength, out-strength, betweenness, eigenvector centrality, and clustering coefficient. Each metric will be stored in a data frame with a unique column name for each season which will then be combined to analyze for repeatability. Additionally, the combined data frame will be mutated so that season and rank (numeric values) are converted to factors. The {igraph} functions degree(), strength(), betweenness(), eigen_centrality(), and transitivity() will be used to calculate the 7 different metrics. For each season I will select individual demographic information and the 7 metrics of interest using the select() function. I did this because the eigen_centrality() function produces a series of extra columns not needed for this analysis.

In addition to calculating all the metrics, I split the full list into one for males and one for females for later analysis based on sex. I also created a data frame which provides the mean and standard deviation of each metric per individual and anoter data frame which does the same but instead groups the data by sex and season.



```{r}
#Calculating metrics for season 1
s1Metrics <- data.frame(ID = elo$ID, Sex = elo$Sex, Season = 1, rank = elo$Elo.May, In.Degree = igraph::degree(s1G, mode = "in"), Out.Degree = igraph::degree(s1G, mode = "out"), In.Strength = igraph::strength(s1G, mode = "in"), Out.Strength = igraph::strength(s1G, mode = "out"), b = igraph::betweenness(s1G, cutoff = -1), EC = eigen_centrality(s1G), CC = igraph::transitivity(s1G, type = "local"), row.names = NULL)
s1Metrics <- s1Metrics |>
  select(ID, Sex, Season, rank, In.Degree, Out.Degree, In.Strength, Out.Strength, b, EC.vector, CC)
head(s1Metrics)
#Calculating metrics for season 2
s2Metrics <- data.frame(ID = elo$ID, Sex = elo$Sex, Season = 2, rank = elo$Elo.Sep, In.Degree = igraph::degree(s2G, mode = "in"), Out.Degree = igraph::degree(s2G, mode = "out"), In.Strength = igraph::strength(s2G, mode = "in"), Out.Strength = igraph::strength(s2G, mode = "out"), b = igraph::betweenness(s2G, cutoff = -1), EC = eigen_centrality(s2G), CC = igraph::transitivity(s2G, type = "local"), row.names = NULL)
s2Metrics <- s2Metrics |>
  select(ID, Sex, Season, rank, In.Degree, Out.Degree, In.Strength, Out.Strength, b, EC.vector, CC)
head(s2Metrics)
#Calculating metrics for season 3
s3Metrics <- data.frame(ID = elo$ID, Sex = elo$Sex, Season = 3, rank = elo$Elo.Dec, In.Degree = igraph::degree(s3G, mode = "in"), Out.Degree = igraph::degree(s3G, mode = "out"), In.Strength = igraph::strength(s3G, mode = "in"), Out.Strength = igraph::strength(s3G, mode = "out"), b = igraph::betweenness(s3G, cutoff = -1), EC = eigen_centrality(s3G), CC = igraph::transitivity(s3G, type = "local"), row.names = NULL)
s3Metrics <- s3Metrics |>
  select(ID, Sex, Season, rank, In.Degree, Out.Degree, In.Strength, Out.Strength, b, EC.vector, CC)
head(s3Metrics)
#Combining metrics into one data.frame
allMetrics <- bind_rows(list(s1Metrics, s2Metrics, s3Metrics))
allMetrics <- allMetrics |>
  mutate(Season = as.factor(Season))
head(allMetrics)
#Creating data for Females and Males
Females <- allMetrics |>
  filter(Sex == "F")
Males <- allMetrics |>
  filter(Sex == "M")

IndivDescrip <- allMetrics |>
  group_by(ID) |>
  summarize(In.Degree.Mean = mean(In.Degree), In.Degree.SD = sd(In.Degree), Out.Degree.Mean = mean(Out.Degree), Out.Degree.SD = sd(In.Degree), In.Strength.Mean = mean(In.Strength), In.Strength.SD = sd(In.Strength), Out.Degree.Mean = mean(Out.Degree), Out.Degree.SD = sd(Out.Degree), Eigenvector.Mean = mean(EC.vector), Eigenvector.SD = sd(EC.vector), Clustering.Coefficient.Mean = mean(CC), Custering.Coefficient.SD = sd(CC), Betweennss.Mean = mean(b), Betweenness.SD = sd(b))
IndivDescrip

SeasonDescrip <- allMetrics |>
  group_by(Sex, Season) |>
  summarize(In.Degree.Mean = mean(In.Degree), In.Degree.SD = sd(In.Degree), Out.Degree.Mean = mean(Out.Degree), Out.Degree.SD = sd(In.Degree), In.Strength.Mean = mean(In.Strength), In.Strength.SD = sd(In.Strength), Out.Degree.Mean = mean(Out.Degree), Out.Degree.SD = sd(Out.Degree), Eigenvector.Mean = mean(EC.vector), Eigenvector.SD = sd(EC.vector), Clustering.Coefficient.Mean = mean(CC), Custering.Coefficient.SD = sd(CC), Betweennss.Mean = mean(b), Betweenness.SD = sd(b))
SeasonDescrip
```



## Plotting Metrics

Here I will use functions from {ggplot2} and {cowplot} to visualize the changes in each metric over the three season. This is meant to reflect the graphs in Figure 2 of the original study



```{r}
#| message: false
#| warning: false
InDegreePlot <- ggplot(data = allMetrics, mapping = aes(x = as.numeric(Season), y = In.Degree, color = ID)) +
  geom_line() +
  theme(legend.position = "none") +
  ggtitle("In-Degree") +
  xlab(label = "Season") +
  ylab(label = "In-Degree")

OutDegreePlot <- ggplot(data = allMetrics, mapping = aes(x = as.numeric(Season), y = Out.Degree, color = ID)) +
  geom_line()+
  theme(legend.position = "none") +
  ggtitle("Out-Degree") +
  xlab(label = "Season") +
  ylab(label = "Out-Degree")

InStrengthPlot <- ggplot(data = allMetrics, mapping = aes(x= as.numeric(Season), y= In.Strength, color = ID)) +
  geom_line()+
  theme(legend.position = "none") +
  ggtitle("In-Strength") +
  xlab(label = "Season") +
  ylab(label = "In-Strength")

OutStrengthPlot <- ggplot(data = allMetrics, mapping = aes(x = as.numeric(Season), y = Out.Strength, color = ID)) +
  geom_line()+
  theme(legend.position = "none") +
  ggtitle("Out-Strength") +
  xlab(label = "Season") +
  ylab(label = "Out-Strength")

betweenPlot <- ggplot(data = allMetrics, mapping = aes(x = as.numeric(Season), y = b, color = ID)) +
  geom_line()+
  theme(legend.position = "none") +
  ggtitle("Betweenness") +
  xlab(label = "Season")

eigenPlot <- ggplot(data = allMetrics, mapping = aes(x = as.numeric(Season), y = EC.vector, color = ID)) +
  geom_line()+
  theme(legend.position = "none") +
  ggtitle("Eigenvector Centrality") +
  xlab(label = "Season")

clusterPlot <- ggplot(data = allMetrics, mapping = aes(x = as.numeric(Season), y = CC, color = ID)) +
  geom_line()+
  theme(legend.position = "none") +
  ggtitle("Clustering Coefficient") +
  xlab(label = "Season")

cowplot <- plot_grid(InDegreePlot, OutDegreePlot, InStrengthPlot, OutStrengthPlot, eigenPlot, clusterPlot, betweenPlot, nrow = 2, ncol = 4)
cowplot
```



These plots are meant to mirror the ones in figure 2 of the original study. My clustering coefficient is the only one which seems to not match the original.

![](Images/Figure2.png)

I will also create boxplots of each metric per sex in each season, recreating Figure 3 in the article. The "fill" argument within ggplot() allows me to make separate boxes based on sex for each season. F indicates Female while M indicates Male



```{r}
#| message: false
#| warning: false

inD <- ggplot(data = allMetrics, mapping = aes(x = Season, y = In.Degree, fill = Sex)) +
  geom_boxplot() +
  ylab(label = "In-Degree") +
  ggtitle("In-Degree")
outD <- ggplot(data = allMetrics, mapping = aes(x = Season, y = Out.Degree, fill = Sex)) +
  geom_boxplot() +
  ylab(label = "Out-Degree") +
  ggtitle("Out-Degree")
inS <- ggplot(data = allMetrics, mapping = aes(x = Season, y = In.Strength, fill = Sex)) +
  geom_boxplot() +
  ylab(label = "In-Strength") +
  ggtitle("In-Strength")
outS <- ggplot(data = allMetrics, mapping = aes(x = Season, y = Out.Strength, fill = Sex)) +
  geom_boxplot() +
  ylab(label = "Out-Degree") +
  ggtitle("Out-Degree")
eigen <- ggplot(data = allMetrics, mapping = aes(x = Season, y = EC.vector, fill = Sex)) +
  geom_boxplot() +
  ylab(label = "Eigenvector Score") +
  ggtitle("Eigenector Centrality")
clust <- ggplot(data = allMetrics, mapping = aes(x = Season, y = CC, fill = Sex)) +
  geom_boxplot() +
  ylab(label = "Clustering Coefficient") +
  ggtitle("Clustering Coefficient")
between <- ggplot(data = allMetrics, mapping = aes(x = Season, y = b, fill = Sex)) +
  geom_boxplot() +
  ylab(label = "Betweenness") +
  ggtitle("Betweenness")

cowplot1 <- plot_grid(inD, outD, inS, outS, eigen, clust, between)
cowplot1
```



These boxplots are meant to resemble figure 3 and appear to deviate from those made in the original study

![](images/Figure3.png)

## Running Models

Now we will fun the repeatability models for each of the metrics. Each of the 7 metrics has 5 models associated with it, 1 for all individual combined, 1 for just females, 1 for just females but with rank as a fixed effect, 1 for just males, and 1 for just males with rank as a fixed effect. All models use the rpt() function from {rptR}. In all models, the season and individual ID are random effects. The grname argument in the function designates how the function should group the data to test for repeatability. Since we are looking for individual repeatability, we will put "ID" here. Gaussian is the data type here as we are dealing with a normal distribution

### In-Degree & Out-Degree



```{r}
#| message: false
#| warning: false
#Degree repeatability
#In-degree
IOm <- rpt(In.Degree ~ (1|ID) + (1|Season),
           grname = "ID",
           data = allMetrics,
           datatype = "Gaussian")
summary(IOm)
#Females
IOmF <- rpt(In.Degree ~ (1|ID) + (1|Season),
            grname = "ID",
            data = Females,
            datatype = "Gaussian")
summary(IOmF)
#Females with Rank
IOmF_rank <- rpt(In.Degree ~ rank + (1|ID) + (1|Season),
                 grname = "ID",
                 data = Females,
                 datatype = "Gaussian")
summary(IOmF_rank)
#Males
IOmM <- rpt(In.Degree ~ (1|ID) + (1|Season),
            grname = "ID",
            data = Males,
            datatype = "Gaussian")
summary(IOmM)
#Males with Rank
IOmM_rank <- rpt(In.Degree ~ rank + (1|ID) + (1|Season),
            grname = "ID",
            data = Males,
            datatype = "Gaussian")
summary(IOmM_rank)
#Out-degree
IOmOut <- rpt(Out.Degree ~ (1|ID) + (1|Season),
              grname = "ID",
              data = allMetrics,
              datatype = "Gaussian")
summary(IOmOut)
#Females
ioOutFemales <- rpt(Out.Degree ~ (1|ID) + (1|Season),
                    grname = "ID",
                    data = Females,
                    datatype = "Gaussian")
summary(ioOutFemales)
#Females with rank
ioOutFemales_rank <- rpt(Out.Degree ~ rank + (1|ID) + (1|Season),
                    grname = "ID",
                    data = Females,
                    datatype = "Gaussian")
summary(ioOutFemales_rank)
#Males
ioOutMales <- rpt(Out.Degree ~ (1|ID) + (1|Season),
                  grname = "ID",
                  data = Males,
                  datatype = "Gaussian")
summary(ioOutMales)
#Males with rank
ioOutMales_rank <- rpt(Out.Degree ~ rank + (1|ID) + (1|Season),
                  grname = "ID",
                  data = Males,
                  datatype = "Gaussian")
summary(ioOutMales_rank)

```



### In-Strength & Out-Strength

The out-strength values used in the male-only models were logged transformed to meet normal distribution assumptions



```{r}
#| message: false
#| warning: false
#Strength Repeatability
#In-Strength
inStrength <- rpt(In.Strength ~ (1|ID) + (1|Season),
                  grname = "ID",
                  data = allMetrics,
                  datatype = "Gaussian")
summary(inStrength)
#Females
inStrengthF <- rpt(In.Strength ~ (1|ID) + (1|Season),
                   grname = "ID",
                   data = Females,
                   datatype = "Gaussian")
summary(inStrengthF)
#Females with rank
inStrengthF_rank <- rpt(In.Degree ~ rank + (1|ID) + (1|Season),
                   grname = "ID",
                   data = Females,
                   datatype = "Gaussian")
summary(inStrengthF_rank)
#Males
inStrengthM <- rpt(In.Degree ~ (1|ID) + (1|Season),
                   grname = "ID",
                   data = Males,
                   datatype = "Gaussian")
summary(inStrengthM)
#Males with rank
inStrengthM_rank <- rpt(In.Strength ~ rank + (1|ID) + (1|Season),
                   grname = "ID",
                   data = Males,
                   datatype = "Gaussian")
summary(inStrengthM_rank)
#Out-Strength
outStrength <- rpt(Out.Strength ~ (1|ID) + (1|Season),
                   grname = "ID",
                   data = allMetrics,
                   datatype = "Gaussian")
summary(outStrength)
#Females
outStrengthF <- rpt(Out.Strength ~ (1|ID) + (1|Season),
                    grname = "ID",
                    data = Females,
                    datatype = "Gaussian")
summary(outStrengthF)
#Females with rank
outStrengthF_rank <- rpt(Out.Strength ~ rank + (1|ID) + (1|Season),
                    grname = "ID",
                    data = Females,
                    datatype = "Gaussian")
summary(outStrengthF_rank)

#Male Out-Strength logged
Males <- Males |>
  mutate(logOutStrength = log(Out.Strength))
#New out strength model
outStrengthM_log <- rpt(logOutStrength ~ (1|ID) + (1|Season),
                    grname = "ID",
                    data = Males,
                    datatype = "Gaussian")
summary(outStrengthM_log)
#Males with rank
outStrengthM_rank_log <- rpt(logOutStrength ~ rank + (1|ID) + (1|Season),
                         grname = "ID",
                         data = Males,
                         datatype = "Gaussian")
summary(outStrengthM_rank_log)
```



### Betweenness

For the betweenness models, a generalized linear mixed effects model (GLMMs) with a Poisson distribution was used instead of the standard linear mixed model. This was done using the rptPoisson() function in {rptR}



```{r}
#| message: false
#| warning: false
#FOR BETWEENNESS: GLMMs w/ Poisson dist
btM_glmm <- rptPoisson(b ~ (1|ID) + (1|Season),
           grname = "ID",
           data = allMetrics)
summary(btM_glmm)
#Females
btM_Females_glmm <- rptPoisson(b ~ (1|ID) + (1|Season),
                   grname = "ID",
                   data = Females)
summary(btM_Females_glmm)
#Females with rank
btM_Females_rank_glmm <- rptPoisson(b ~ rank + (1|ID) + (1|Season),
                        grname = "ID",
                        data = Females)
summary(btM_Females_rank_glmm)
#Males
btM_Males_glmm <- rptPoisson(b ~ (1|ID) + (1|Season),
                 grname = "ID",
                 data = Males)
summary(btM_Males_glmm)
#Males with rank
btM_Males_rank_glmm <- rptPoisson(b ~ rank + (1|ID) + (1|Season),
                      grname = "ID",
                      data = Males)
summary(btM_Males_rank_glmm)
```



### Eigenvector Centrality

Male-only models had eigenvector centrality log transformed to meet model assumptions



```{r}
#| message: false
#| warning: false
#Eigenvector Centrality
egCent <- rpt(EC.vector ~ (1|ID) + (1|Season),
              grname = "ID",
              data = allMetrics,
              datatype = "Gaussian")
summary(egCent)
#Females
egCentF <- rpt(EC.vector ~ (1|ID) + (1|Season),
               grname = "ID",
               data = Females,
               datatype = "Gaussian")
summary(egCentF)
#Females with rank
egCentF_rank <- rpt(EC.vector ~ rank + (1|ID) + (1|Season),
               grname = "ID",
               data = Females,
               datatype = "Gaussian")
summary(egCentF_rank)

#Male eigenvectors logged
Males <- Males |>
  mutate(logEC = log(EC.vector))
#New eigenvector model
egCentM_log <- rpt(logEC ~ (1|ID) + (1|Season),
               grname = "ID",
               data = Males,
               datatype = "Gaussian")
summary(egCentM_log)
#Males with rank
egCentM_rank_log <- rpt(logEC ~ rank + (1|ID) + (1|Season),
                    grname = "ID",
                    data = Males,
                    datatype = "Gaussian")
summary(egCentM_rank_log)
```



### Clustering Coefficient



```{r}
#| message: false
#| warning: false
#Clustering coefficient, may need to recheck
ccM <- rpt(CC ~ (1|ID) + (1|Season),
           grname = "ID",
           data = allMetrics,
           datatype = "Gaussian")
summary(ccM)
#Females
ccM_Females <- rpt(CC ~ (1|ID) + (1|Season),
                   grname = "ID",
                   data = Females,
                   datatype = "Gaussian")
summary(ccM_Females)
#Females with rank
ccM_Females_rank <- rpt(CC ~ rank + (1|ID) + (1|Season),
                   grname = "ID",
                   data = Females,
                   datatype = "Gaussian")
summary(ccM_Females_rank)
#Males
ccM_Males <- rpt(CC ~ (1|ID) + (1|Season),
                 grname = "ID",
                 data = Males,
                 datatype = "Gaussian")
summary(ccM_Males)
#Males with rank
ccM_Males_rank <- rpt(CC ~ rank + (1|ID) + (1|Season),
                 grname = "ID",
                 data = Males,
                 datatype = "Gaussian")
summary(ccM_Males_rank)
```



### Extract R and CIs

Here I am creating a list of all the models and running them through a function to easily extract the R estimate and 95% confidence intervals. The getR function does this for all the models except for betweenness. Since betweenness was run using rptPoisson() the formatting of the results requires a different approach to extract.



```{r}
getR <- function(model) {
  d <- data.frame(R = as.numeric(model$R["ID"]), CI = paste(model$CI_emp["ID", "2.5%"], "-", model$CI_emp["ID", "97.5%"]))
  return(d)
}
getRb <- function(model) {
  d <- data.frame(R = model$R$ID[2], CI = paste(model$CI_emp$CI_link["ID", "2.5%"], "-", model$CI_emp$CI_link["ID", "97.5%"]))
  return(d)
}
models <- list(In.Degree = IOm, In.Degree.Females = IOmF, In.Degree.Females.Rank = IOmF_rank, In.Degree.Males = IOmM, In.Degree.Males.Rank = IOmM_rank, Out.Degree = IOmOut, Out.Degree.Females = ioOutFemales, Out.Degree.Females.Rank = ioOutFemales_rank, Out.Degree.Males = ioOutMales, Out.Degree.Males.Rank = ioOutMales_rank, In.Strength = inStrength, In.Strength.Females = inStrengthF, In.Strenght.Females.Rank = inStrengthF_rank, In.Strenght.Males = inStrengthM, In.Strength.Males.Rank = inStrengthM_rank, Out.Strength = outStrength, Out.Strength.Females = outStrengthF, Out.Strength.Females.Rank = outStrengthF_rank, Out.Strength.Males = outStrengthM_log, Out.Strength.Males.Rank = outStrengthM_rank_log, Eigenvector = egCent, Eigenvector.Females = egCentF, Eigenvector.Females.Rank = egCentF_rank, Eigenvector.Males = egCentM_log, Eigenvector.Males.Rank = egCentM_rank_log, Clustering = ccM, Clustering.Females = ccM_Females, Clustering.Females.Rank = ccM_Females_rank, Clustering.Males = ccM_Males, Clustering.Males.Rank = ccM_Males_rank)

x <- lapply(models, getR)
results <- do.call(rbind, x)
results <- results |>
  mutate(Metric.Sample = c("In-Degree", "In-Degree Females", "In-Degree Female Rank", "In-Degree Males", "In-Degree Males Rank", "Out-Degree", "Out-Degree Females", "Out-Degree Females Rank", "Out-Degree Males", "Out-Degree Males Rank", "In-Strength", "In-Strength Females", "In-Strength Females Rank", "In-Strength Males", "In-Strength Males Rank", "Out-Strength", "Out-Strength Females", "Out-Strength Females Rank", "Out-Strength Males", "Out-Strength Males Rank", "Eigenvector", "Eigenvector Females", "Eigenvector Females Rank", "Eigenvector Males", "Eigenvector Males Rank", "Clustering Coefficient", "Clustering Coefficient Females", "Clustering Coefficient Females Rank", "Clustering Coefficient Males", "Clustering Coefficient Males Rank"))

#Betweenness
modelB <- list(Betweenness = btM_glmm, Betweenness.Females = btM_Females_glmm, Betweenness.Females.Rank = btM_Females_rank_glmm, Betweenness.Males = btM_Males_glmm, Betweenness.Males.Rank = btM_Males_rank_glmm)
xB <- lapply(modelB, getRb)
resultsB <- do.call(rbind, xB)
resultsB <- resultsB |>
  mutate(Metric.Sample = c("Betweenness", "Betweenness Females", "Betweenness Females Rank", "Betweenness Males", "Betweenness Males Rank"))

allResults <- bind_rows(list(results, resultsB))
allResults <- allResults |>
  relocate(Metric.Sample, .before = R)
rownames(allResults) <- NULL
allResults
```



Table 2 of the original study provides the repeatability estimate (R), 95% confidence interval (CI), and the p-value of each repeatability estimate based on a node permutation test. The table below it summarizes the R and CI values returned by the models I ran

![](images/Table2.png){fig-align="center" width="242"}

## Node-Based Permuation

Since individual network metric are not independent of other network members, the orignal study used a node-based permutatio approach to tests for the significance of each repeatability estimate. Individual IDs were randomized for each of the three networks before running a new repeatability model. This was repeated 1000 times. I built the following function to do this easily for each metric. The first is for the standard node based permutation, the next is for the GLMMs used for betweennenss. While the original study ran 1000 permutations, I only ran 10 as 1000 took more time and processing power than I had (I tried doing 1000 and letting it run over night and it didnt even finish the first network metric). Thus, my p-values will be different from the original study due to a smaller sample size.



```{r}
#| message: false
#| warning: false
nodePerm <- function(df, n, formula){
  permN <- do(n) * {
    permd <- df
    permd$ID = sample(permd$ID)
    m <- rpt(formula,
             grname = "ID",
             data = permd,
             datatype = "Gaussian")
    data.frame(R = m$R$ID)
  }
  return(permN)
}
nodePermGlmm <- function(df, n, formula){
  permN <- do(n) * {
    permd <- df
    permd$ID = sample(permd$ID)
    m <- rptPoisson(formula,
                    grname = "ID",
                    data = permd)
    data.frame(R = m$R$ID)
  }
  return(permN)
}
```



### In-Degree & Out-Degree

Now I will start running the node based permutations, first for in-degree and out-degree. The p-value is calculated by taking the repeatability estimates from the node-based permutation and comparing them to the original estimate. The study used a two-tailed p-value which we will calculate using the method seen first in the variable inDegPval. This method will be repeated for each metric with minor edits to each to ensure that the proper data is being examined.



```{r, message=FALSE, warning=FALSE}
#| message: false
#| warning: false
#In-degree
inDegPerm <- nodePerm(df = allMetrics, n = 10, formula = In.Degree ~ (1|ID) + (1|Season))
inDegPval <- (sum(inDegPerm$R >= abs(IOm$R)) + sum(inDegPerm$R <= -abs(IOm$R)))/10

#In Degree Females
inDegPermF <- nodePerm(df = Females, n = 10, formula = In.Degree ~ (1|ID) + (1|Season))
inDegPermF_pval <- (sum(inDegPermF$R >= abs(IOmF$R)) + sum(inDegPermF$R <= -abs(IOmF$R)))/10

#In Degree Females w/ rank
inDegPermFrank <- nodePerm(df = Females, n = 10, formula = In.Degree ~ rank + (1|ID) + (1|Season))
inDegPermFrank_pval <- (sum(inDegPermFrank$R >= abs(IOmF_rank$R)) + sum(inDegPermFrank$R <= -abs(IOmF_rank$R)))/10

#In Degree Males
inDegPermM <- nodePerm(df = Males, n = 10, formula = In.Degree ~ (1|ID) + (1|Season))
inDegPermM_pval <- (sum(inDegPermM$R >= abs(IOmM$R)) + sum(inDegPermM$R <= -abs(IOmM$R)))/10

#In Degree Males w/ rank
inDegPermMrank <- nodePerm(df = Males, n = 10, formula = In.Degree ~ rank + (1|ID) + (1|Season))
inDegPermMrank_pval <- (sum(inDegPermMrank$R >= abs(IOmM_rank$R)) + sum(inDegPermMrank$R <= -abs(IOmM_rank$R)))/10

#Out degree
outDegPerm <- nodePerm(df = allMetrics, n = 10, formula = Out.Degree ~ (1|ID) + (1|Season))
outDegPval <- (sum(outDegPerm$R >= abs(IOmOut$R)) + sum(outDegPerm$R <= -abs(IOmOut$R)))/10

#Out degree females
outDegPermF <- nodePerm(df = Females, n = 10, formula = Out.Degree ~ (1|ID) + (1|Season))
outDegPermF_pval <- (sum(outDegPermF$R >= abs(ioOutFemales$R)) + sum(outDegPermF$R <= -abs(ioOutFemales$R)))/10

#Out degree females w/ rank
outDegPermFrank <- nodePerm(df = Females, n = 10, formula = Out.Degree ~ rank + (1|ID) + (1|Season))
outDegPermFrank_pval <- (sum(outDegPermFrank$R >= abs(ioOutFemales_rank$R)) + sum(outDegPermFrank$R <= -abs(ioOutFemales_rank$R)))/10

#Out degree males
outDegPermM <- nodePerm(df = Males, n = 10, formula = Out.Degree ~ (1|ID) + (1|Season))
outDegPermM_pval <- (sum(outDegPermM$R >= abs(ioOutMales$R)) + sum(outDegPermM$R <= -abs(ioOutMales$R)))/10

#Out degree males w/ rank
outDegPermMrank <- nodePerm(df = Males, n = 10, formula = Out.Degree ~ rank + (1|ID) + (1|Season))
outDegPermMrank_pval <- (sum(outDegPermMrank$R >= abs(ioOutMales_rank$R)) + sum(outDegPermMrank$R <= -abs(ioOutMales_rank$R)))/10
```



### In-Strength & Out-Strength



```{r, message=FALSE, warning=FALSE}
#| message: false
#| warning: false
#In-strength
inStrengthPerm <- nodePerm(df = allMetrics, n = 10, formula = In.Strength ~ (1|ID) + (1|Season))
inStrengthPerm_pval <- (sum(inStrengthPerm$R >= abs(inStrength$R)) + sum(inStrengthPerm$R <= -abs(inStrength$R)))/10

#In-strength females
inStrengthPermF <- nodePerm(df = Females, n = 10, formula = In.Strength ~ (1|ID) + (1|Season))
inStrengthPermF_pval <- (sum(inStrengthPermF$R >= abs(inStrengthF$R)) + sum(inStrengthPermF$R <= -abs(inStrengthF$R)))/10

#In-strength females w/ rank
inStrengthPermFrank <- nodePerm(df = Females, n = 10, formula = In.Strength ~ rank + (1|ID) + (1|Season))
inStrengthPermFrank_pval <- (sum(inStrengthPermFrank$R >= abs(inStrengthF_rank$R)) + sum(inStrengthPermFrank$R <= -abs(inStrengthF_rank$R)))/10

#In-strength Males
inStrengthPermM <- nodePerm(df = Males, n = 10, formula = In.Strength ~ (1|ID) + (1|Season))
inStrengthPermM_pval <- (sum(inStrengthPermM$R >= abs(inStrengthM$R)) + sum(inStrengthPermM$R <= -abs(inStrengthM$R)))/10

#In-strength Males w/ rank
inStrengthPermMrank <- nodePerm(df = Males, n = 10, formula = In.Strength ~ rank + (1|ID) + (1|Season))
inStrengthPermMrank_pval <- (sum(inStrengthPermMrank$R >= abs(inStrengthM_rank$R)) + sum(inStrengthPermMrank$R <= -abs(inStrengthM_rank$R)))/10

#Out-strength
outStrengthPerm <- nodePerm(df = allMetrics, n = 10, formula = Out.Strength ~ (1|ID) + (1|Season))
outStrengthPerm_pval <- (sum(outStrengthPerm$R >= abs(outStrength$R)) + sum(outStrengthPerm$R <= -abs(outStrength$R)))/10

#out-strength females
outStrengthPermF <- nodePerm(df = Females, n = 10, formula = Out.Strength ~ (1|ID) + (1|Season))
outStrengthPermF_pval <- (sum(outStrengthPermF$R >= abs(outStrengthF$R)) + sum(outStrengthPermF$R <= -abs(outStrengthF$R)))/10

#out-strength females w/ rank
outStrengthPermFrank <- nodePerm(df = Females, n = 10, formula = Out.Strength ~ rank + (1|ID) + (1|Season))
outStrengthPermFrank_pval <- (sum(outStrengthPermFrank$R >= abs(outStrengthF_rank$R)) + sum(outStrengthPermFrank$R <= -abs(outStrengthF_rank$R)))/10

#out-strength Males
outStrengthPermM <- nodePerm(df = Males, n = 10, formula = logOutStrength ~ (1|ID) + (1|Season))
outStrengthPermM_pval <- (sum(outStrengthPermM$R >= abs(outStrengthM_log$R)) + sum(outStrengthPermM$R <= -abs(outStrengthM_log$R)))/10

#out-strength Males w/ rank
outStrengthPermMrank <- nodePerm(df = Males, n = 10, formula = logOutStrength ~ rank + (1|ID) + (1|Season))
outStrengthPermMrank_pval <- (sum(outStrengthPermMrank$R >= abs(outStrengthM_rank_log$R)) + sum(outStrengthPermMrank$R <= -abs(outStrengthM_rank_log$R)))/10
```



### Betweenness



```{r, message=FALSE, warning=FALSE}
#| message: false
#| warning: false

#Betweenness
btPerm <- nodePermGlmm(df = allMetrics, n = 10, formula = b ~ (1|ID) + (1|Season))
btPerm_pval <- (sum(btPerm$R >= abs(btM_glmm$R)) + sum(btPerm$R <= -abs(btM_glmm$R)))/10

#Female betweenness
btPermF <- nodePermGlmm(df = Females, n = 10, formula = b ~ (1|ID) + (1|Season))
btPermF_pval <- (sum(btPermF$R >= abs(btM_Females_glmm$R)) + sum(btPermF$R <= -abs(btM_Females_glmm$R)))/10

#Female betweenness w/ rank
btPermFrank <- nodePermGlmm(df = Females, n = 10, formula = b ~ rank + (1|ID) + (1|Season))
btPermFrank_pval <- (sum(btPermFrank$R >= abs(btM_Females_rank_glmm$R)) + sum(btPermFrank$R <= -abs(btM_Females_rank_glmm$R)))/10

#Male betweenness
btPermM <- nodePermGlmm(df = Males, n =10, formula = b ~ (1|ID) + (1|Season))
btPermM_pval <- (sum(btPermM$R >= abs(btM_Males_glmm$R)) + sum(btPermM$R <= -abs(btM_Males_glmm$R)))/10

#Male betweenness w/ rank
btPermMrank <- nodePermGlmm(df = Males, n = 10, formula = b ~ (1|ID) + (1|Season))
btPermMrank_pval <- (sum(btPermMrank$R >= abs(btM_Males_rank_glmm$R)) + sum(btPermMrank$R <= -abs(btM_Males_rank_glmm$R)))/10
```



### Eigenvector Centrality



```{r, message=FALSE, warning=FALSE}
#| message: false
#| warning: false

#Eigenvector
ecPerm <- nodePerm(df = allMetrics, n = 10, formula = EC.vector ~ (1|ID) + (1|Season))
ecPerm_pval <- (sum(ecPerm$R >= abs(egCent$R)) + sum(ecPerm$R <= -abs(egCent$R)))/10

#Female eigenvector
ecPermF <- nodePerm(df = Females, n = 10, formula = EC.vector ~ (1|ID) + (1|Season))
ecPermF_pval <- (sum(ecPermF$R >= abs(egCentF$R)) + sum(ecPermF$R <= -abs(egCentF$R)))/10

#Female eigenvector w/ rank
ecPermFrank <- nodePerm(df = Females, n = 10, formula = EC.vector ~ rank + (1|ID) + (1|Season))
ecPermFrank_pval <- (sum(ecPermFrank$R >= abs(egCentF_rank$R)) + sum(ecPermFrank$R <= -abs(egCentF_rank$R)))/10

#Male eigenvector
ecPermM <- nodePerm(df = Males, n = 10, formula = logEC ~ (1|ID) + (1|Season))
ecPermM_pval <- (sum(ecPermM$R >= abs(egCentM_log$R)) + sum(ecPermM$R <= -abs(egCentM_log$R)))/10

#Male eigenvector w/ rank
ecPermMrank <- nodePerm(df = Males, n = 10, formula = logEC ~ rank + (1|ID) + (1|Season))
ecPermMrank_pval <- (sum(ecPermMrank$R >= abs(egCentM_rank_log$R)) + sum(ecPermMrank$R <= -abs(egCentM_rank_log$R)))/10
```



### Clustering Coefficient



```{r, message=FALSE, warning=FALSE}
#| message: false
#| warning: false
#Clustering Coefficient
ccPerm <- nodePerm(df = allMetrics, n = 10, formula = CC ~ (1|ID) + (1|Season))
ccPerm_pval <- (sum(ccPerm$R >= abs(ccM$R)) + sum(ccPerm$R <= -abs(ccM$R)))/10

#Female CC
ccPermF <- nodePerm(df = Females, n = 10, formula = CC ~ (1|ID) + (1|Season))
ccPermF_pval <- (sum(ccPermF$R >= abs(ccM_Females$R)) + sum(ccPermF$R <= -abs(ccM_Females$R)))/10

#Female CC w/ rank
ccPermFrank <- nodePerm(df = Females, n = 10, formula = CC ~ rank + (1|ID) + (1|Season))
ccPermFrank_pval <- (sum(ccPermFrank$R >= abs(ccM_Females_rank$R)) + sum(ccPermFrank$R <= -abs(ccM_Females_rank$R)))/10

#Male CC
ccPermM <- nodePerm(df = Males, n = 10, formula = CC ~ (1|ID) + (1|Season))
ccPermM_pval <- (sum(ccPermM$R >= abs(ccM_Males$R)) + sum(ccPermM$R <= -abs(ccM_Males$R)))/10

#Male CC w/ rank
ccPermMrank <- nodePerm(df = Males, n = 10, formula = CC ~ rank + (1|ID) + (1|Season))
ccPermMrank_pval <- (sum(ccPermMrank$R >= abs(ccM_Males_rank$R)) + sum(ccPermMrank$R <= -abs(ccM_Males_rank$R)))/10
```



### Adding to Results

Now we will add all of these p-values to the results table I made earlier



```{r}
allResults <- allResults |>
  mutate(p = c(inDegPval, inDegPermF_pval, inDegPermFrank_pval, inDegPermM_pval, inDegPermMrank_pval, outDegPval, outDegPermF_pval, outDegPermFrank_pval, outDegPermM_pval, outDegPermMrank_pval, inStrengthPerm_pval, inStrengthPermF_pval, inStrengthPermFrank_pval, inStrengthPermM_pval, inStrengthPermMrank_pval, outStrengthPerm_pval, outStrengthPermF_pval, outStrengthPermFrank_pval, outStrengthPermM_pval, outStrengthPermMrank_pval, ecPerm_pval, ecPermF_pval, ecPermFrank_pval, ecPermM_pval, ecPermMrank_pval, ccPerm_pval, ccPermF_pval, ccPermFrank_pval, ccPermM_pval, ccPermMrank_pval, btPerm_pval, btPermF_pval, btPermFrank_pval, btPermM_pval, btPermMrank_pval))
allResults
```



Here is table 2 again so we can compare the p-values from the original study to the p-values I generated

![](Images/Table2.png){fig-align="center"}

## Correlating Metrics

The study used Spearman rank correlations to assess for collinearity between each pair of network metrics. First I created a data frame to store all the network metrics data only, and then passed it through the cor() function from {stats} and with the method argument set to "spearman". I will use the cor_pmat() function from {rstatix} package to calculate the p-values associated with each pair of metrics. The results can be compared to Table 1 of the original study.



```{r}
#| message: false
#| warning: false
network_metrics <- data.frame(In.Degree = allMetrics$In.Degree, Out.Degree = allMetrics$Out.Degree, In.Strength = allMetrics$In.Strength, Out.Strength = allMetrics$Out.Strength, Eigenvector = allMetrics$EC.vector, Cluster = allMetrics$CC, Between = allMetrics$b)
spearCor <- cor(network_metrics, method = "spearman")

spearCor_p <- cor_pmat(
  data = network_metrics,
  vars = NULL,
  method = "spearman",
  alternative = "two.sided",
  conf.level = 0.95)

spearCor
spearCor_p
```



![](Images/Table1.png)

## Rank and Sex Models

In addition to the repeatability models, the study used (G)LMMs to investigate the effects of sex and rank differences on each of the 7 metrics.

For the sex models, "sex" was included as a fixed effect and ID and Season were again random effects. For the betweenness Poisson GLMM, an observational level random effect was included. After the models were run, node based permutation was run again for 1000 but with sex being randomized instead of ID.

For the rank models, males and females were analyzed separately and "rank" was a fixed effects with ID and Season as random effects. The rest of the analysis matched how the sex model was carried out. All mixed models were fit using functions in the {lme4} package.

Below are the functions needed to do the node based permutations. They have been adjusted slightly to account for the different analysis



```{r}
#| message: false
#| warning: false
#These two are for node based permutations for sex
nodePermSex <- function(df, n, formula){
  permN <- do(n) * {
    permd <- df
    permd$Sex = sample(permd$Sex)
    m <- lmer(formula,
             data = permd)
    coef_sex <- fixef(m)["SexM"]
    data.frame(perm_est = coef_sex)
  }
  return(permN)
}
nodePermGlmmSex <- function(df, n, formula){
  permN <- do(n) * {
    permd <- df
    permd$Sex = sample(permd$Sex)
    m <- glmer(formula,
                    data = permd,
            family = poisson)
    coef_sex <- fixef(m)["SexM"]
    data.frame(perm_est = coef_sex)
  }
  return(permN)
}
#These 2 are for node based permutations of rank based on differences in sex
nodePermRank <- function(df, n, formula){
  permN <- do(n) * {
    permd <- df
    permd$rank = sample(permd$rank)
    m <- lmer(formula,
             data = permd)
    coef_rank <- fixef(m)["rank"]
    data.frame(perm_est = coef_rank)
  }
  return(permN)
}
nodePermGlmmRank <- function(df, n, formula){
  permN <- do(n) * {
    permd <- df
    permd$rank = sample(permd$rank)
    m <- glmer(formula,
                    data = permd,
            family = poisson)
    coef_rank <- fixef(m)["rank"]
    data.frame(perm_est = coef_rank)
  }
  return(permN)
}
```



### Sex (G)LMMs

Here, I now am running both each lmer() model with Sex as a fixed effect and then running the node-based permutation to then calculate the p-value. The est variable temporarily hold the original estimate for each model to compare to the permuted estimates to get the p-value



```{r}
#| message: false
#| warning: false
#sex as fixed effect
#In/Out Degree
inD_sex <- lmer(In.Degree ~ (1|ID) + (1|Season) + Sex,
                data = allMetrics)

x <- summary(inD_sex)
inD_c <- x$coefficients

est <- inD_c["SexM", "Estimate"]
p <- nodePermSex(allMetrics, n = 1000, formula = In.Degree ~ (1|ID) + (1|Season) + Sex)
inDp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

outD_sex <- lmer(Out.Degree ~ (1|ID) + (1|Season) + Sex,
                 data = allMetrics)
x <- summary(outD_sex)
outD_c <- x$coefficients
est <- outD_c["SexM", "Estimate"]
p <- nodePermSex(allMetrics, n = 1000, formula = Out.Degree ~ (1|ID) + (1|Season) + Sex)
outDp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#In/Out Strength
inS_sex <- lmer(In.Strength ~ (1|ID) + (1|Season) + Sex,
                data = allMetrics)
x <- summary(inS_sex)
inS_c <- x$coefficients
est <- inS_c["SexM", "Estimate"]
p <- nodePermSex(allMetrics, n = 1000, formula = In.Strength ~ (1|ID) + (1|Season) + Sex)
inSp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

outS_sex <- lmer(Out.Strength ~ (1|ID) + (1|Season) + Sex,
                 data = allMetrics)
x <- summary(outS_sex)
outS_c <- x$coefficients
est <- outS_c["SexM", "Estimate"]
p <- nodePermSex(allMetrics, n = 1000, formula = Out.Strength ~ (1|ID) + (1|Season) + Sex)
outSp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#Eigenvector Centrality
eg_sex <- lmer(EC.vector ~ (1|ID) + (1|Season) + Sex,
               data = allMetrics)
x <- summary(eg_sex)
eg_c <- x$coefficients
est <- eg_c["SexM", "Estimate"]
p <- nodePermSex(allMetrics, n = 1000, formula = EC.vector ~ (1|ID) + (1|Season) + Sex)
EGp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#Betweenness
allMetrics <- allMetrics |>
  mutate(observation.id = factor(1:nrow(allMetrics)))
bt_sex <- glmer(b ~ (1|ID) + (1|Season) + (1|observation.id) + Sex,
                data = allMetrics,
                family = poisson)
x <- summary(bt_sex)
bt_c <- x$coefficients
est <- bt_c["SexM", "Estimate"]
p <- nodePermGlmmSex(allMetrics, n = 1000, formula = b ~ (1|ID) + (1|Season) + Sex)
BTp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#Clustering Coefficient
cc_sex <- lmer(CC ~ (1|ID) + (1|Season) + Sex,
               data = allMetrics)
x <- summary(cc_sex)
cc_c <- x$coefficients
est <- cc_c["SexM", "Estimate"]
p <- nodePermSex(allMetrics, n = 1000, formula = CC ~ (1|ID) + (1|Season) + Sex)
CCp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

print(paste("In-Degree p-value:", inDp, "; Out-Degree p-value:", outDp, "; In-Strength p-value:", inSp, "; Out-Strength p-value:", outSp, "; Eigenvector p-value:", EGp, "; Clustering Coefficient p-value:", CCp, "; Betweenness p-value:", BTp))

sexResults <- data.frame(Metric.Sample = c("In-Degree", "Out-Degree", "In-Strength", "Out.Strength", "Eigenvector", "Clustering Coefficient", "Betweennes"), Estimate = c(inD_c["SexM", "Estimate"], outD_c["SexM", "Estimate"], inS_c["SexM", "Estimate"], outS_c["SexM", "Estimate"], eg_c["SexM", "Estimate"], cc_c["SexM", "Estimate"], bt_c["SexM", "Estimate"]), Standard.Error = c(inD_c["SexM", "Std. Error"], outD_c["SexM", "Std. Error"], inS_c["SexM", "Std. Error"], outS_c["SexM", "Std. Error"], eg_c["SexM", "Std. Error"], cc_c["SexM", "Std. Error"], bt_c["SexM", "Std. Error"]), p = c(inDp, outDp, inSp, outSp, EGp, CCp, BTp))
sexResults
```



The results calculate above are meant to reflect those found in Table 3. My results appear to differ from what the original study found. This may point out an area where the methods of the study were not specific enough to fully replicate as I will discuss later.

![](images/Table3.png)

### Rank (G)LMMs



```{r}
#| message: false
#| warning: false
#Rank as fixed effect for Females
#In-Degree
inDF_rank <- lmer(In.Degree ~ (1|ID) + (1|Season) + rank,
                  data = Females)
x <- summary(inDF_rank)
inDF_rankc <- x$coefficients

est <- inDF_rankc["rank", "Estimate"]
p <- nodePermRank(Females, n = 1000, formula = In.Degree ~ (1|ID) + (1|Season) + rank)
inDFrankp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#Out-Degree
outDF_rank <- lmer(Out.Degree ~ (1|ID) + (1|Season) + rank,
                   data = Females)
x <- summary(outDF_rank)
outDF_rankc <- x$coefficients

est <- outDF_rankc["rank", "Estimate"]
p <- nodePermRank(Females, n = 1000, formula = Out.Degree ~ (1|ID) + (1|Season) + rank)
outDFrankp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#In-Strength
inSF_rank <- lmer(In.Strength ~ (1|ID) + (1|Season) + rank,
                  data = Females)
x <- summary(inSF_rank)
inSF_rankc <- x$coefficients

est <- inSF_rankc["rank", "Estimate"]
p <- nodePermRank(Females, n = 1000, formula = In.Strength ~ (1|ID) + (1|Season) + rank)
inSFrankp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#Out-Strength
outSF_rank <- lmer(Out.Strength ~ (1|ID) + (1|Season) + rank,
                   data = Females)
x <- summary(outSF_rank)
outSF_rankc <- x$coefficients

est <- outSF_rankc["rank", "Estimate"]
p <- nodePermRank(Females, n = 1000, formula = Out.Strength ~ (1|ID) + (1|Season) + rank)
outSFrankp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#Eigenvector
egF_rank <- lmer(EC.vector ~ (1|ID) + (1|Season) + rank,
                 data = Females)
x <- summary(egF_rank)
egF_rankc <- x$coefficients

est <- egF_rankc["rank", "Estimate"]
p <- nodePermRank(Females, n = 1000, formula = EC.vector ~ (1|ID) + (1|Season) + rank)
egFrankp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#Betweenness
Females <- Females |>
  mutate(observation.id = factor(1:nrow(Females)))
btF_rank <- glmer(b ~ (1|ID) + (1|Season) + (1|observation.id) + rank,
                  data = Females,
                  family = poisson)
x <- summary(btF_rank)
btF_rankc <- x$coefficients

est <- btF_rankc["rank", "Estimate"]
p <- nodePermGlmmRank(Females, n = 1000, formula = b ~ (1|ID) + (1|Season) + (1|observation.id) + rank)
btFrankp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#Clustering coefficient
ccF_rank <- lmer(CC ~ (1|ID) + (1|Season) + rank,
                 data = Females)
x <- summary(ccF_rank)
ccF_rankc <- x$coefficients

est <- ccF_rankc["rank", "Estimate"]
p <- nodePermRank(Females, n = 1000, formula = CC ~ (1|ID) + (1|Season) + rank)
ccFrankp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

print(paste("Female p-values: In-Degree p-value:", inDFrankp, "; Out-Degree p-value:", outDFrankp, "; In-Strength p-value:", inSFrankp, "; Out-Strength p-value:", outSFrankp, "; Eigenvector p-value:", egFrankp, "; Betweenness p-value:", btFrankp, "; Clustering Coefficient p-value:", ccFrankp))
#########################################################################################################################################################################################################################################################
#Rank as fixed effect males
#In-degree
inDM_rank <- lmer(In.Degree ~ (1|ID) + (1|Season) + rank,
                  data = Males)
x <- summary(inDM_rank)
inDM_rankc <- x$coefficients

est <- inDM_rankc["rank", "Estimate"]
p <- nodePermRank(Males, n = 1000, formula = In.Degree ~ (1|ID) + (1|Season) + rank)
inDMrankp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#Out-degree
outDM_rank <- lmer(Out.Degree ~ (1|ID) + (1|Season) + rank,
                   data = Males)
x <- summary(outDM_rank)
outDM_rankc <- x$coefficients

est <- outDM_rankc["rank", "Estimate"]
p <- nodePermRank(Males, n = 1000, formula = Out.Degree ~ (1|ID) + (1|Season) + rank)
outDMrankp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#In-Stength
inSM_rank <- lmer(In.Strength ~ (1|ID) + (1|Season) + rank,
                  data = Males)
x <- summary(inSM_rank)
inSM_rankc <- x$coefficients

est <- inDM_rankc["rank", "Estimate"]
p <- nodePermRank(Males, n = 1000, formula = In.Strength ~ (1|ID) + (1|Season) + rank)
inSMrankp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#Out-Strength
outSM_rank <- lmer(Out.Strength ~ (1|ID) + (1|Season) + rank,
                   data = Males)
x <- summary(outSM_rank)
outSM_rankc <- x$coefficients

est <- outSM_rankc["rank", "Estimate"]
p <- nodePermRank(Males, n = 1000, formula = Out.Strength ~ (1|ID) + (1|Season) + rank)
outSMrankp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#Eigenvector
egM_rank <- lmer(EC.vector ~ (1|ID) + (1|Season) + rank,
                 data = Males)
x <- summary(egM_rank)
egM_rankc <- x$coefficients

est <- egM_rankc["rank", "Estimate"]
p <- nodePermRank(Males, n = 1000, formula = EC.vector ~ (1|ID) + (1|Season) + rank)
egMrankp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#Betweenness
Males <- Males |>
  mutate(observation.id = factor(1:nrow(Males)))
btM_rank <- glmer(b ~ (1|ID) + (1|Season) + (1|observation.id) + rank,
                  data = Males,
                  family = poisson)
x <- summary(btM_rank)
btM_rankc <- x$coefficients

est <- btM_rankc["rank", "Estimate"]
p <- nodePermGlmmRank(Males, n = 1000, formula = b ~ (1|ID) + (1|Season) + (1|observation.id) + rank)
btMrankp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

#Clustering coefficient
ccM_rank <- lmer(CC ~ (1|ID) + (1|Season) + rank,
                 data = Males)
x <- summary(ccM_rank)
ccM_rankc <- x$coefficients

est <- ccM_rankc["rank", "Estimate"]
p <- nodePermRank(Males, n = 1000, formula = CC ~ (1|ID) + (1|Season) + rank)
ccMrankp <- (sum(p$perm_est >= abs(est)) + sum(p$perm_est <= -abs(est)))/1000

print(paste("Male p-values: In-Degree p-value:", inDMrankp, "; Out-Degree p-value:", outDMrankp, "; In-Strength p-value:", inSMrankp, "; Out-Strength p-value:", outSMrankp, "; Eigenvector p-value:", egMrankp, "; Clustering Coefficient p-value:", ccMrankp, "; Betweenness p-value:", btMrankp))

rankResults <- data.frame(Metric.Sample = c("In-Degree Females", "In-Degree Males", "Out-Degree Females", "Out-Degree Males", "In-Strength Females", "In-Strength Males", "Out-Strength Females", "Out-Strength Males", "Eigenvector Females", "Eigenvector Males", "Clustering Coefficient Females", "Clustering Coefficient Males", "Betweenness", "Betweenness"), Estimate = c(inDF_rankc["rank", "Estimate"], inDM_rankc["rank", "Estimate"], outDF_rankc["rank", "Estimate"], outDM_rankc["rank", "Estimate"], inSF_rankc["rank", "Estimate"], inSM_rankc["rank", "Estimate"], outSF_rankc["rank", "Estimate"], outSM_rankc["rank", "Estimate"], egF_rankc["rank", "Estimate"], egM_rankc["rank", "Estimate"], ccF_rankc["rank", "Estimate"], ccM_rankc["rank", "Estimate"],btF_rankc["rank", "Estimate"], btM_rankc["rank", "Estimate"]), Standard.Error = c(inDF_rankc["rank", "Std. Error"], inDM_rankc["rank", "Std. Error"], outDF_rankc["rank", "Std. Error"], outDM_rankc["rank", "Std. Error"], inSF_rankc["rank", "Std. Error"], inSM_rankc["rank", "Std. Error"], outSF_rankc["rank", "Std. Error"], outSM_rankc["rank", "Std. Error"], egF_rankc["rank", "Std. Error"], egM_rankc["rank", "Std. Error"], ccF_rankc["rank", "Std. Error"], ccM_rankc["rank", "Std. Error"],btF_rankc["rank", "Std. Error"], btM_rankc["rank", "Std. Error"]), p = c(inDFrankp, inDMrankp, outDFrankp, outDMrankp, inSFrankp, inSMrankp, outSFrankp, outSMrankp, egFrankp, egMrankp, ccFrankp, ccMrankp, btFrankp, btMrankp))
rankResults
```



These results are mean to mirror those of table 4. My results here, similar to the models I ran for sex, are different from the original study and show again how the methods may not have been clear enough to fully replicate.

![](images/Table4.png)

## Replication Successes, Challenges, and Shortcoming

In replicating this study, I was able to (i) create social grooming networks for each of the three seasons, (ii) calculate the 7 metrics used, (iii) plot changes in these metrics over the three seasons and between sexes, (iv) calculate the repeatability of each metric across time using formulas in the {rptR} package, and (v) calculate the effects of sex and rank differences on network metrics. My results were most successful at replicating the repeatability estimates and confidence intervals, plotting the network metrics, and calculating the spearman rank correlation.

For the most part, I faced very few challenges in replicating this analysis. The article had a readme file attached with it which made it very clear what each data file was so I had no confusion determining which data to use for the analysis. Additionally, the article made it clear what packages were used for the bulk of the analysis, particurally {igraph}, {rptR}, and {lme4}. Using these as a starting point, I was able to estimate what functions were used after looking at the documentation, studies references, and comparing the results I got to the original ones. For other aspects of the analysis, such as the plots and spearman correlation, I used proir knowledge with {ggplot2} and {cowplot} along with some googling to determine the best way to calculate the spearman correlation and p-values. The one challenge I had for a little while was determining how to do the node-based permutation. I had a difficult time wrapping my head around how exactly to code it for a minute but eventually determined that the rpt() function needed to be nested within a standard permutation loop. Also related to the node based permutations, I ran mine with 10 permutations rather than 1000 due to time contraints, and thus my p-values for the repeatability of network metrics are different from the original study.

While I was successful in running the different analyses used, I got some conflicting results. Going all the way back to calculating the network metrics, my clustering coefficient values did not match those in the original study. I started with the transitivity() function from {igraph} and then tried some methods using different packages and data formats but continued to get the same result. It was indicated in the study that {igraph} was used to calculate all the metrics, so I assumed that was the proper function to use. It was not clear in the original study what method could have also been used to calculate this. Since my clustering coefficient values were off, subsequent analysis of repeatability and the effects of dominance rank and sex were also off. The (G)LMMs to test the effects of sex and dominance rank were also off when I ran my analysis. While the methods listed how the formula should be sex up (metric \~ (1\|ID) + (1\|Season) + sex or rank) it did not list any other specifications for the lmer() or glmer() functions. My analysis results might differ from the original results due to different functions used to calculate the clustering coefficient and/or the (G)LMMs. I also may not have used all the proper parameters for the (G)LMMs which may be why they values are different.

## Directory

Below is a table of the different variables created and what they each represent. Variables are listed in the order they appear in the code

| Variable | Definition |
|------------------------------------|------------------------------------|
| f, f1, f2, f3 | Holds links to initial datasets stored in github repo |
| elo | Dataset associated with f which holds demographic and seasonal ranking information for each individual in the data set |
| s1, s2, s3 | Grooming dyads for each of the three seasons and data on how long each grooming dyad took place |
| com | All three seasons data compiled into a single dataframe |
| s1edges, s2edges, s3edges | The edge widths determined by grooming rate for each dyad which is used to create each seasons social network |
| s1G, s2G, s3G | Directed {igraph} network for each of the three seasons |
| nsize1, nsize2, nsize3 | Variable to calculate and store the size of each node in the network plots based on unweighted degree |
| s1p, s2p, s3p | Plotted {igraph} social networks |
| s1Metrics, s2Metrics, s3Metrics | Data frames storing the network metrics of each individual per season |
| allMetrics | Compiled data frame of each seasons metrics |
| Females, Males | Data frame containing the network metrics of individuals based on their sex (female or male) |
| IndivDescrip | Mean and standard deviations for each individuals set of network metrics |
| SeasonDescrip | Mean and standard deviations for each network metric grouped by sex and season |
| InDegreePlot, OutDegreePlot, InStrengthPlot, OutStrengthPlot, betweenPlot, eigenPlot, clusterPlot | Line graphs plotting each individuals variation in network metric across the three seasons |
| inD, outD, inS, outS, clust, eigen, between | Boxplots showing range of values for each metrics per sex per season |
| cowplot, cowplot1 | Grid plots which contain all the line graphs and boxplots respectively |
| IOm, IOmF, IOmF_rank, IOmM, IOmM_rank | In-degree repeatabiliy models for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| IOmOut, ioOutFemales, ioOutFemales_rank | Out-degree repeatabiliy models for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| inStrength, inStrengthF, inStrengthF_rank, inStrengthM, inStrengthM_rank | In-strength repeatabiliy models for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| outStrength, outStrengthF, outStrengthF_rank, outStrengthM_log, outStrengthM_rank_log | Out-strength repeatabiliy models for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| egCent, egCentF, egCentF_rank, egCentM_log, egCentM_rank_log | Eigenvector centrality repeatabiliy models for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| ccM, ccM_Females, ccM_Females_rank, ccM_Males, ccM_Males_rank | Clustering Coefficient repeatabiliy models for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| btM_glmm, btM_Females_glmm, btM_Females_rank_glmm, btM_Males_glmm, btM_Males_rank_glmm | Betweenness repeatabiliy models for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| getR, getRB | Functions to extract the repeatability estimate and confidence intervals from the rpt() and rptPoisson() models respectively |
| models | List of all the repeatabiliy models using rpt() |
| results | Data frame storing the repeatability estimate and confidence intervals of each model |
| modelsB | Betweenness models which used rptPoisson() |
| resultsB | Data frame storing the repeatabiliy estimate and confidence intervals for the betweenness models |
| allResults | Compiled data frame all the results of all the models |
| nodePerm, nodePermGlmm | Functions for running node based permutations on each metric for the repeatability models |
| inDegPerm, inDegF, inDegFrank, inDegM, inDegMrank | In-degree node based permutations for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| inDegPval, inDegPermF_pval, inDegPermFrank_pval, inDegPermM_pval, inDegPermMrank_pval | In-degree p-values based on node based permutations for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| outDegPerm, outDegPermF, outDegPermFrank, outDegPermM, outDegPermMrank | Out-degree node based permutations for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| outDegPval, outDegPermF_pval, outDegPermFrank_pval, outDegPermM_pval, outDegPermMrank_pval | Out-degree p-values based on node based permutations for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| inStrengthPerm, inStrengthPermF, inStrengthPermFrank, inStrengthPermM, inStrengthPermMrank | In-strength node based permutations for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| inStrengthPerm_pval, inStrengthPermF_pval, inStrengthPermFrank_pval, inStrengthPermM_pval, inStrengthPermMrank_pval | In-strength p-values based on node based permutations for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| outStrengthPerm, outStrengthPermF, outStrengthPermFrank, outStrengthPermM, outStrengthPermMrank | Out-strength node based permutations for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| outStrengthPerm_pval, outStrengthPermF_pval, outStrengthPermFrank_pval, outStrengthPermM_pval, outStrengthPermMrank_pval | Out-strength p-values based on node based permutations for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| ecPerm, ecPermF, ecPermFrank, ecPermM, ecPermMrank | Eigenvector node based permutations for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| ecPerm_pval, ecPermF_pval, ecPermFrank_pval, ecPermM_pval, ecPermMrank_pval | Eigenvector p-values based on node based permutations for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| btPerm, btPermF, btPermFrank, btPermM, btPermMrank | Betweenness node based permutations for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| btPerm_pval, btPermF_pval, btPermFrank_pval, btPermM_pval, btPermMrank_pval | Betweenness p-values based on node based permutations for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| ccPerm, ccPermF, ccPermFrank, ccPermM, ccPermMrank | Clustering Coefficient node based permutations for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| ccPerm_pval, ccPermF_pval, ccPermFrank_pval, ccPermM_pval, ccPermMrank_pval | Clustering Coefficient p-values based on node based permutations for all individuals, females, females with rank as a fixed effect, males, and males with rank as a fixed effect |
| network_metrics | Data frame containing just the network metrics for correlation |
| spearCor | Spearman's rank correlation of all 7 network metrics |
| spearCor_p | P-values associated with the spearman correlation for each pair of metric correlations |
| nodePermSex, nodePermGlmmSex | Functions for running node-based permutations of each metric with sex being shuffled |
| nodePermRank, notPermGlmmRank | Functions for running node-based permutations of each metric with rank being shuffled |
| inD_sex, outD_sex, inS_sex, outS_sex, eg_sex, bt_sex, cc_sex | Variables holding the (G)LMMs run for in-degree, out-degree, in-strength, out-strength, eigenvector, betweenness, and clustering coefficient with sex as a fixed effect |
| x | Temporary variable to hold the summary of each (G)LMMs for models ran with sex or rank as a fixed effect |
| inD_c, outD_c, inS_c, outS_c, eg_c, bt_c, cc_c | Variables storing the coefficients for each (G)LMM model with sex as a fixed effect |
| est | Temporary variable holding the estimate value of each (G)LMM model ran with sex or rank as a fixed effect |
| p | Temporary variable holding the sex or rank node based permutation function for each metric. |
| inDp, outDp, inSp, outSp, EGp, BTp, CCp | Variables which hold the p-value calculated after running the node based permutation test for in-degree, out-degree, in-strength, out-strength, eigenvector, betweenness, and clustering coefficient |
| sexResults | Data frame storing the estimates, standard error, and p-value for each of the (G)LMMs ran with sex as a fixed effect |
| inDF_rank, outDF_rank, inSF_rank, outSF_rank, egF_rank, btF_rank, ccF_rank | Variables which hold the results of (G)LMMs for female in-degree, out-degree, in-strength, out-strenght, eigenvector, betweenness, and clustering coefficient with rank as a fixed effect |
| inDF_rankc, outDF_rankc, inSF_rankc, outSF_rankc, egF_rankc, btF_rankc, ccF_rankc | Variables holding the coefficients generated by the (G)LMMs for female in-degree, out-degree, in-strength, out-strenght, eigenvector, betweenness, and clustering coefficient with rank as a fixed effect |
| inDFrankp, outDFrankp, inSFrankp, outSFrankp, egFrankp, btFrankp, ccFrankp | Variables storing the p-value calculated after comparing the values of the node based permutation with the original estimates for female in-degree, out-degree, in-strength, out-strenght, eigenvector, betweenness, and clustering coefficient with rank as a fixed effect |
| inDM_rank, outDM_rank, inSM_rank, outSM_rank, egM_rank, btM_rank, ccM_rank | Variables which hold the results of (G)LMMs for male in-degree, out-degree, in-strength, out-strenght, eigenvector, betweenness, and clustering coefficient with rank as a fixed effect |
| inDM_rankc, outDM_rankc, inSM_rankc, outSM_rankc, egM_rankc, btM_rankc, ccM_rankc | Variables holding the coefficients generated by the (G)LMMs for male in-degree, out-degree, in-strength, out-strenght, eigenvector, betweenness, and clustering coefficient with rank as a fixed effect |
| inDMrankp, outDMrankp, inSMrankp, outSMrankp, egMrankp, btMrankp, ccMrankp | Variables storing the p-value calculated after comparing the values of the node based permutation with the original estimates for male in-degree, out-degree, in-strength, out-strenght, eigenvector, betweenness, and clustering coefficient with rank as a fixed effect |
| rankResults | Data frame storing the estimates, standard errors, and p-values for each (G)LMM run on the network metrics |

