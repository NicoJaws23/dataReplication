---
title: "dataReplication"
format: html
editor: visual
---

# Data Replication Project: Replicating a Social Network Analysis

[**Based on: Blaszczyk, M. B. (2018). Consistency in social network position over changing environments in a seasonally breeding primate. *Behavioral Ecology and Sociobiology*, *72*(1), 11. <https://doi.org/10.1007/s00265-017-2425-y>**]{.underline}

## Background

### Aims

The original study cited above aimed to investigate the consistency of social behavior in wild vervet monkeys (*Chlorocubus pygerthrus*) across three seasons, the breeding season, winter season, and birthing season. Blaszczyk created grooming networks for each season and measured the repeatability of seven network metrics (In-/Out-degree, In-/Out-strength, betweenness, eigenvector centrality, and clustering coefficient) along with the effects of sex and dominance rank on these metrics.

### Data Used

Blaszczyk used 20-minute continuous focal sampling to record grooming bouts lasting at least 5 seconds. The final data included who groomed and who was groomed, how long the grooming bout lasted, the total number of minutes the actor and receiver were seen, the total amount of time in seconds the same dyad was seen together, and grooming rate (grooming bout time/time dyad seen together). A different dataset was used for each season, resulting in three unique datasets characterizing grooming dyads for the group under study. Additionally, individuals' IDs, sex, and elo rating for each season was stored in a fourth dataset.

### Analysis

The initial analysis used function in the {igraph} package to construct grooming networks for each season. These networks were one directed and weighted based on grooming rate. {igraph} as also used to calculate the seven network metrics. Elo-ratings were calculated using the {EloRating} package and converted to ranks on the last day of each season (IDs_Sex_EloScores in OGData). To test the repeatability of each metric across seasons, linear mixed effects models (LMMs) were run using the {rptR} package. Models were run for the whole mixed sex sample (n = 26), females (n = 16), and males (n = 10) with season being a random effect. These models were also all run again with rank included as a fixed effect. Additionally, sex was used as a fixed effect for (G)LMMs to examine sex differences and the effects of dominance rank on all social network metrics. Node-based permutation tests with 1000 iterations were used on all metrics to evaluate the significance of repeatability. In order to test for the collinearity between each pair of metrics, Spearman rank correlation was used. All mixed models were fit with the {lme4} package.

### Conclusions

Blaszczyk found that, based on the repeatability of each network metric, vervet monkey social network position was consistent over the three seasons. Grooming in-strength, out-strength, eigenvector centrality, and in-degree were the most repeatable for both sexes. Betweenness showed no consistency across seasons for both sexes. Only males were consistent in out-degree and clustering coefficients.

## Tools

First, we will load in the libraries with the functions we need to conduct the analysis

```{r}
#| message: false
#| warning: false
library(tidyverse)
library(igraph)
library(rptR)
library(lme4)
library(ggplot2)
library(cowplot)
library(mosaic)
```

## Data

Next, we will load in the data using the raw links provided by github. Each of these files can be found in the github repository. The elo variable will hold the data with demographic details and elo rating, s1 will hold all the season 1 data, s2 will hold the season 2 data, and s3 will hold the season 3 data.

```{r}
#| message: false
#| warning: false
f <- "https://raw.githubusercontent.com/NicoJaws23/dataReplication/refs/heads/main/IDs_Sex_EloScores.csv"
elo <- read_csv(f)
head(elo)

f1 <- "https://raw.githubusercontent.com/NicoJaws23/dataReplication/refs/heads/main/GroomDyads_S1.csv"
s1 <- read_csv(f1)
head(s1)

f2 <- "https://raw.githubusercontent.com/NicoJaws23/dataReplication/refs/heads/main/GroomDyads_S2.csv"
s2 <- read_csv(f2)
head(s2)

f3 <- "https://raw.githubusercontent.com/NicoJaws23/dataReplication/refs/heads/main/GroomDyads_S3.csv"
s3 <- read_csv(f3)
head(s3)
```

## Adjustments

Next, we will make some adjustments to the original data. Considering that the analysis uses season as a random effect, we ill add a column which holds a value for the corresponding season. We will also have a name for the season held in another column along with columns which convert the groom time and dyad time to minutes. Finally, we will combine all the data into one data frame.

```{r}
#| message: false
#| warning: false
s1 <- mutate(s1, Season = 1, sType = "Mating", groomMin = total.groom.secs/60, dyadObsMin = dyad.obs.secs/60)
s2 <- mutate(s2, Season = 2, sType = "Winter", groomMin = total.groom.secs/60, dyadObsMin = dyad.obs.secs/60)
s3 <- mutate(s3, Season = 3, sType = "Birth", groomMin = total.groom.secs/60, dyadObsMin = dyad.obs.secs/60)

#Combine all 3 seasons into one big table
com <- bind_rows(list(s1, s2, s3))

```

## Plots

Now will will plot each seasons social network. First, we need to define the edges for each network which we will store in a variable names sXEdges. This will be a data frame with the actor, recipient, and grooming rate. Next we will graph the social network using the graph_from_data_frame() function which will take out edges data as an argument along with setting directed to TRUE. In the original study, females are white circles while males are gray circles. To do this, we will call the colors of the vertices of the graph and set them to be based on vertices name which is based on each individuals ID. This will be linked to the elo table which has the sex of each individual which be used to assign the proper color to each vertex. Then, using the plot.igraph() function, we will plot the social network. This will be repeated for each season. I was not able to figure out how to combine all three figures into one nice row, but it is meant to represent figure 1.

### Season 1

```{r}
#| message: false
#| warning: false
#Season 1
s1Edges <- data.frame(from = s1$"Actor", to = s1$"Recip", weight = s1$groom.rate)
s1G <- graph_from_data_frame(d = s1Edges, directed = TRUE)
deg1 <- degree(s1G)
nsize1 <- 5 + 15*(deg1/max(deg1))
edges1 <- s1Edges$weight/max(s1Edges$weight) * 5

V(s1G)$color <- sapply(V(s1G)$name, function(name) {
  row <- which(elo$ID == name)
  if(elo$Sex[row] == "F") {
    "white"
  } else {
    "gray"
  }
})

s1p <- plot.igraph(s1G, 
            vertex.shape = "circle",
            vertex.size = nsize1,
            vertex.color = V(s1G)$color,
            vertex.label = "",
            edge.width = edges1,
            edge.arrow.size = 0.3,
            edge.curved = .5,
            main = c("Season 1",
            "March - May",
            "FOH = 497", " ND = 0.45"))
```

### Season 2

```{r}
#| message: false
#| warning: false
s2Edges <- data.frame(from = s2$"Actor", to = s2$"Recip", weight = s2$groom.rate)
s2G <- graph_from_data_frame(d = s2Edges, directed = TRUE)
deg2 <- degree(s2G)
nsize2 <- 5 + 15*(deg2/max(deg2))
edges2 <- s2Edges$weight/max(s2Edges$weight) * 5

V(s2G)$color <- sapply(V(s2G)$name, function(name) {
  row <- which(elo$ID == name)
  if(elo$Sex[row] == "F") {
    "white"
  } else {
    "gray"
  }
})

s2p <- plot.igraph(s2G, 
            vertex.shape = "circle",
            vertex.size = nsize2,
            vertex.color = V(s1G)$color,
            vertex.label = "",
            edge.curved = .75,
            edge.width = edges2,
            edge.arrow.size = 0.3,
            main = c("Season 2",
            "June - September",
            "FOH = 967.1", " ND = 0.71"))
```

### Season 3

```{r}
#| message: false
#| warning: false
s3Edges <- data.frame(from = s3$"Actor", to = s3$"Recip", weight = s3$groom.rate)
s3G <- graph_from_data_frame(d = s3Edges, directed = TRUE)
deg3 <- degree(s3G)
nsize3 <- 5 + 15*(deg3/max(deg3))
edges3 <- s3Edges$weight/max(s3Edges$weight) * 5

V(s3G)$color <- sapply(V(s3G)$name, function(name) {
  row <- which(elo$ID == name)
  if(elo$Sex[row] == "F") {
    "white"
  } else {
    "gray"
  }
})

s3p <- plot.igraph(s3G, 
            vertex.shape = "circle",
            vertex.size = nsize3,
            vertex.color = V(s1G)$color,
            vertex.label = "",
            edge.curved = .75,
            edge.arrow.size = 0.3,
            edge.width = edges3,
            main = c("Season 3",
            "October - December",
            "FOH = 705.2", " ND = 0.52"))
```

My networks closely approximate those in the original study in Figure 1

![](TablesFigures/Figure1.png)

## Calculating Metrics

Next, we will calculate the each of the 7 metrics used in the study, in-degree, out-degree, in-strength, out-strength, betweenness, eigenvector centrality, and clustering coefficient. Each metric will be stored in a data frame with a unique column name for each season which will then be combined to analyze for repeatability. Additionally, the combined data frame will be mutated so that season and rank (numeric values) are converted to factors. The {igraph} functions degree(), strength(), betweenness(), eigen_centrality(), and transitivity() will be used to calculate the 7 different metrics. For each season I will select individual demographic information and the 7 metrics of interest using the select() function. I did this because the eigen_centrality() function produces a series of extra columns not needed for this analysis.

```{r}
#Calculating metrics for season 1
s1Metrics <- data.frame(ID = elo$ID, Sex = elo$Sex, Season = 1, rank = elo$Elo.May, In.Degree = igraph::degree(s1G, mode = "in"), Out.Degree = igraph::degree(s1G, mode = "out"), In.Strength = igraph::strength(s1G, mode = "in"), Out.Strength = igraph::strength(s1G, mode = "out"), b = igraph::betweenness(s1G, cutoff = -1), EC = eigen_centrality(s1G), CC = igraph::transitivity(s1G, type = "local"), row.names = NULL)
s1Metrics <- s1Metrics |>
  select(ID, Sex, Season, rank, In.Degree, Out.Degree, In.Strength, Out.Strength, b, EC.vector, CC)
head(s1Metrics)
#Calculating metrics for season 2
s2Metrics <- data.frame(ID = elo$ID, Sex = elo$Sex, Season = 2, rank = elo$Elo.Sep, In.Degree = igraph::degree(s2G, mode = "in"), Out.Degree = igraph::degree(s2G, mode = "out"), In.Strength = igraph::strength(s2G, mode = "in"), Out.Strength = igraph::strength(s2G, mode = "out"), b = igraph::betweenness(s2G, cutoff = -1), EC = eigen_centrality(s2G), CC = igraph::transitivity(s2G, type = "local"), row.names = NULL)
s2Metrics <- s2Metrics |>
  select(ID, Sex, Season, rank, In.Degree, Out.Degree, In.Strength, Out.Strength, b, EC.vector, CC)
head(s2Metrics)
#Calculating metrics for season 3
s3Metrics <- data.frame(ID = elo$ID, Sex = elo$Sex, Season = 3, rank = elo$Elo.Dec, In.Degree = igraph::degree(s3G, mode = "in"), Out.Degree = igraph::degree(s3G, mode = "out"), In.Strength = igraph::strength(s3G, mode = "in"), Out.Strength = igraph::strength(s3G, mode = "out"), b = igraph::betweenness(s3G, cutoff = -1), EC = eigen_centrality(s3G), CC = igraph::transitivity(s3G, type = "local"), row.names = NULL)
s3Metrics <- s3Metrics |>
  select(ID, Sex, Season, rank, In.Degree, Out.Degree, In.Strength, Out.Strength, b, EC.vector, CC)
head(s3Metrics)
#Combining metrics into one data.frame
allMetrics <- bind_rows(list(s1Metrics, s2Metrics, s3Metrics))
allMetrics <- allMetrics |>
  mutate(Season = as.factor(Season))
head(allMetrics)
#Creating data for Females and Males
Females <- allMetrics |>
  filter(Sex == "F")
Males <- allMetrics |>
  filter(Sex == "M")
```

## Plotting Metrics

Here I will use functions from {ggplot2} and {cowplot} to visualize the changes in each metric over the three season. This is meant to reflect the graphs in Figure 2 of the original study

```{r}
#| message: false
#| warning: false
InDegreePlot <- ggplot(data = allMetrics, mapping = aes(x = as.numeric(Season), y = In.Degree, color = ID)) +
  geom_line() +
  theme(legend.position = "none") +
  ggtitle("In-Degree") +
  xlab(label = "Season") +
  ylab(label = "In-Degree")

OutDegreePlot <- ggplot(data = allMetrics, mapping = aes(x = as.numeric(Season), y = Out.Degree, color = ID)) +
  geom_line()+
  theme(legend.position = "none") +
  ggtitle("Out-Degree") +
  xlab(label = "Season") +
  ylab(label = "Out-Degree")

InStrengthPlot <- ggplot(data = allMetrics, mapping = aes(x= as.numeric(Season), y= In.Strength, color = ID)) +
  geom_line()+
  theme(legend.position = "none") +
  ggtitle("In-Strength") +
  xlab(label = "Season") +
  ylab(label = "In-Strength")

OutStrengthPlot <- ggplot(data = allMetrics, mapping = aes(x = as.numeric(Season), y = Out.Strength, color = ID)) +
  geom_line()+
  theme(legend.position = "none") +
  ggtitle("Out-Strength") +
  xlab(label = "Season") +
  ylab(label = "Out-Strength")

betweenPlot <- ggplot(data = allMetrics, mapping = aes(x = as.numeric(Season), y = b, color = ID)) +
  geom_line()+
  theme(legend.position = "none") +
  ggtitle("Betweenness") +
  xlab(label = "Season")

eigenPlot <- ggplot(data = allMetrics, mapping = aes(x = as.numeric(Season), y = EC.vector, color = ID)) +
  geom_line()+
  theme(legend.position = "none") +
  ggtitle("Eigenvector Centrality") +
  xlab(label = "Season")

clusterPlot <- ggplot(data = allMetrics, mapping = aes(x = as.numeric(Season), y = CC, color = ID)) +
  geom_line()+
  theme(legend.position = "none") +
  ggtitle("Clustering Coefficient") +
  xlab(label = "Season")

cowplot <- plot_grid(InDegreePlot, OutDegreePlot, InStrengthPlot, OutStrengthPlot, eigenPlot, clusterPlot, betweenPlot, nrow = 2, ncol = 4)
cowplot
```

These plots are meant to mirror the ones in figure 2 of the original study. My clustering coefficient is the only one which seems to not match the original.

![](TablesFigures/Figure2.png)

I will also create boxplots of each metric per sex in each season, recreating Figure 3 in the article. The "fill" argument within ggplot() allows me to make separate boxes based on sex for each season. F indicates Female while M indicates Male

```{r}
#| message: false
#| warning: false

inD <- ggplot(data = allMetrics, mapping = aes(x = Season, y = In.Degree, fill = Sex)) +
  geom_boxplot() +
  ylab(label = "In-Degree") +
  ggtitle("In-Degree")
outD <- ggplot(data = allMetrics, mapping = aes(x = Season, y = Out.Degree, fill = Sex)) +
  geom_boxplot() +
  ylab(label = "Out-Degree") +
  ggtitle("Out-Degree")
inS <- ggplot(data = allMetrics, mapping = aes(x = Season, y = In.Strength, fill = Sex)) +
  geom_boxplot() +
  ylab(label = "In-Strength") +
  ggtitle("In-Strength")
outS <- ggplot(data = allMetrics, mapping = aes(x = Season, y = Out.Strength, fill = Sex)) +
  geom_boxplot() +
  ylab(label = "Out-Degree") +
  ggtitle("Out-Degree")
eigen <- ggplot(data = allMetrics, mapping = aes(x = Season, y = EC.vector, fill = Sex)) +
  geom_boxplot() +
  ylab(label = "Eigenvector Score") +
  ggtitle("Eigenector Centrality")
clust <- ggplot(data = allMetrics, mapping = aes(x = Season, y = CC, fill = Sex)) +
  geom_boxplot() +
  ylab(label = "Clustering Coefficient") +
  ggtitle("Clustering Coefficient")
between <- ggplot(data = allMetrics, mapping = aes(x = Season, y = b, fill = Sex)) +
  geom_boxplot() +
  ylab(label = "Betweenness") +
  ggtitle("Betweenness")
plot_grid(inD, outD, inS, outS, eigen, clust, between)
```

These boxplots are meant to resemble figure 3 and appear to deviate from those made in the original study

![](TablesFigures/Figure3.png)

## Running Models

Now we will fun the repeatability models for each of the metrics. Each of the 7 metrics has 5 models associated with it, 1 for all individual combined, 1 for just females, 1 for just females but with rank as a fixed effect, 1 for just males, and 1 for just males with rank as a fixed effect. All models use the rpt() function from {rptR}. In all models, the season and individual ID are random effects

### In-Degree & Out-Degree

```{r}
#| message: false
#| warning: false
#Degree repeatability
#In-degree
IOm <- rpt(In.Degree ~ (1|ID) + (1|Season),
           grname = "ID",
           data = allMetrics,
           datatype = "Gaussian")
summary(IOm)
#Females
IOmF <- rpt(In.Degree ~ (1|ID) + (1|Season),
            grname = "ID",
            data = Females,
            datatype = "Gaussian")
summary(IOmF)
#Females with Rank
IOmF_rank <- rpt(In.Degree ~ rank + (1|ID) + (1|Season),
                 grname = "ID",
                 data = Females,
                 datatype = "Gaussian")
summary(IOmF_rank)
#Males
IOmM <- rpt(In.Degree ~ (1|ID) + (1|Season),
            grname = "ID",
            data = Males,
            datatype = "Gaussian")
summary(IOmM)
#Males with Rank
IOmM_rank <- rpt(In.Degree ~ rank + (1|ID) + (1|Season),
            grname = "ID",
            data = Males,
            datatype = "Gaussian")
summary(IOmM_rank)
#Out-degree
IOmOut <- rpt(Out.Degree ~ (1|ID) + (1|Season),
              grname = "ID",
              data = allMetrics,
              datatype = "Gaussian")
summary(IOmOut)
#Females
ioOutFemales <- rpt(Out.Degree ~ (1|ID) + (1|Season),
                    grname = "ID",
                    data = Females,
                    datatype = "Gaussian")
summary(ioOutFemales)
#Females with rank
ioOutFemales_rank <- rpt(Out.Degree ~ rank + (1|ID) + (1|Season),
                    grname = "ID",
                    data = Females,
                    datatype = "Gaussian")
summary(ioOutFemales_rank)
#Males
ioOutMales <- rpt(Out.Degree ~ (1|ID) + (1|Season),
                  grname = "ID",
                  data = Males,
                  datatype = "Gaussian")
summary(ioOutMales)
#Males with rank
ioOutMales_rank <- rpt(Out.Degree ~ rank + (1|ID) + (1|Season),
                  grname = "ID",
                  data = Males,
                  datatype = "Gaussian")
summary(ioOutMales_rank)

```

### In-Strength & Out-Strength

The out-strength values used in the male-only models were logged transformed to meet assumptions

```{r}
#| message: false
#| warning: false
#Strength Repeatability
#In-Strength
inStrength <- rpt(In.Strength ~ (1|ID) + (1|Season),
                  grname = "ID",
                  data = allMetrics,
                  datatype = "Gaussian")
summary(inStrength)
#Females
inStrengthF <- rpt(In.Strength ~ (1|ID) + (1|Season),
                   grname = "ID",
                   data = Females,
                   datatype = "Gaussian")
summary(inStrengthF)
#Females with rank
inStrengthF_rank <- rpt(In.Degree ~ rank + (1|ID) + (1|Season),
                   grname = "ID",
                   data = Females,
                   datatype = "Gaussian")
summary(inStrengthF_rank)
#Males
inStrengthM <- rpt(In.Degree ~ (1|ID) + (1|Season),
                   grname = "ID",
                   data = Males,
                   datatype = "Gaussian")
summary(inStrengthM)
#Males with rank
inStrengthM_rank <- rpt(In.Strength ~ rank + (1|ID) + (1|Season),
                   grname = "ID",
                   data = Males,
                   datatype = "Gaussian")
summary(inStrengthM_rank)
#Out-Strength
outStrength <- rpt(Out.Strength ~ (1|ID) + (1|Season),
                   grname = "ID",
                   data = allMetrics,
                   datatype = "Gaussian")
summary(outStrength)
#Females
outStrengthF <- rpt(Out.Strength ~ (1|ID) + (1|Season),
                    grname = "ID",
                    data = Females,
                    datatype = "Gaussian")
summary(outStrengthF)
#Females with rank
outStrengthF_rank <- rpt(Out.Strength ~ rank + (1|ID) + (1|Season),
                    grname = "ID",
                    data = Females,
                    datatype = "Gaussian")
summary(outStrengthF_rank)

#Male Out-Strength logged
Males <- Males |>
  mutate(logOutStrength = log(Out.Strength))
#New out strength model
outStrengthM_log <- rpt(logOutStrength ~ (1|ID) + (1|Season),
                    grname = "ID",
                    data = Males,
                    datatype = "Gaussian")
summary(outStrengthM_log)
#Males with rank
outStrengthM_rank_log <- rpt(logOutStrength ~ rank + (1|ID) + (1|Season),
                         grname = "ID",
                         data = Males,
                         datatype = "Gaussian")
summary(outStrengthM_rank_log)
```

### Betweenness

For the betweenness models, a generalized linear mixed effects model (GLMMs) with a Poisson distribution was used instead of the standard linear mixed model. This was done using the rptPoisson() function in {rptR}

```{r}
#| message: false
#| warning: false
#FOR BETWEENNESS: GLMMs w/ Poisson dist
btM_glmm <- rptPoisson(b ~ (1|ID) + (1|Season),
           grname = "ID",
           data = allMetrics)
summary(btM_glmm)
#Females
btM_Females_glmm <- rptPoisson(b ~ (1|ID) + (1|Season),
                   grname = "ID",
                   data = Females)
summary(btM_Females_glmm)
#Females with rank
btM_Females_rank_glmm <- rptPoisson(b ~ rank + (1|ID) + (1|Season),
                        grname = "ID",
                        data = Females)
summary(btM_Females_rank_glmm)
#Males
btM_Males_glmm <- rptPoisson(b ~ (1|ID) + (1|Season),
                 grname = "ID",
                 data = Males)
summary(btM_Males_glmm)
#Males with rank
btM_Males_rank_glmm <- rptPoisson(b ~ rank + (1|ID) + (1|Season),
                      grname = "ID",
                      data = Males)
summary(btM_Males_rank_glmm)
```

### Eigenvector Centrality

Male-only models had eigenvector centrality log transformed to meet model assumptions

```{r}
#| message: false
#| warning: false
#Eigenvector Centrality
egCent <- rpt(EC.vector ~ (1|ID) + (1|Season),
              grname = "ID",
              data = allMetrics,
              datatype = "Gaussian")
summary(egCent)
#Females
egCentF <- rpt(EC.vector ~ (1|ID) + (1|Season),
               grname = "ID",
               data = Females,
               datatype = "Gaussian")
summary(egCentF)
#Females with rank
egCentF_rank <- rpt(EC.vector ~ rank + (1|ID) + (1|Season),
               grname = "ID",
               data = Females,
               datatype = "Gaussian")
summary(egCentF_rank)

#Male eigenvectors logged
Males <- Males |>
  mutate(logEC = log(EC.vector))
#New eigenvector model
egCentM_log <- rpt(logEC ~ (1|ID) + (1|Season),
               grname = "ID",
               data = Males,
               datatype = "Gaussian")
summary(egCentM_log)
#Males with rank
egCentM_rank_log <- rpt(logEC ~ rank + (1|ID) + (1|Season),
                    grname = "ID",
                    data = Males,
                    datatype = "Gaussian")
summary(egCentM_rank_log)
```

### Clustering Coefficient

```{r}
#| message: false
#| warning: false
#Clustering coefficient, may need to recheck
ccM <- rpt(CC ~ (1|ID) + (1|Season),
           grname = "ID",
           data = allMetrics,
           datatype = "Gaussian")
summary(ccM)
#Females
ccM_Females <- rpt(CC ~ (1|ID) + (1|Season),
                   grname = "ID",
                   data = Females,
                   datatype = "Gaussian")
summary(ccM_Females)
#Females with rank
ccM_Females_rank <- rpt(CC ~ rank + (1|ID) + (1|Season),
                   grname = "ID",
                   data = Females,
                   datatype = "Gaussian")
summary(ccM_Females_rank)
#Males
ccM_Males <- rpt(CC ~ (1|ID) + (1|Season),
                 grname = "ID",
                 data = Males,
                 datatype = "Gaussian")
summary(ccM_Males)
#Males with rank
ccM_Males_rank <- rpt(CC ~ rank + (1|ID) + (1|Season),
                 grname = "ID",
                 data = Males,
                 datatype = "Gaussian")
summary(ccM_Males_rank)
```

### Extract R and CIs

Here I am creating a list of all the models and running them through a function to easily extract the R estimate and 95% confidence intervals

```{r}
getR <- function(model) {
  d <- data.frame(R = model$R["ID"], CI = paste(model$CI_emp["ID", "2.5%"], "-", model$CI_emp["ID", "97.5%"]))
  return(d)
}
getRb <- function(model) {
  d <- data.frame(R = model$R$ID[2], CI = paste(model$CI_emp$CI_link["ID", "2.5%"], "-", model$CI_emp$CI_link["ID", "97.5%"]))
  return(d)
}
models <- list(In.Degree = IOm, In.Degree.Females = IOmF, In.Degree.Females.Rank = IOmF_rank, In.Degree.Males = IOmM, In.Degree.Males.Rank = IOmM_rank, Out.Degree = IOmOut, Out.Degree.Females = ioOutFemales, Out.Degree.Females.Rank = ioOutFemales_rank, Out.Degree.Males = ioOutMales, Out.Degree.Males.Rank = ioOutMales_rank, In.Strength = inStrength, In.Strength.Females = inStrengthF, In.Strenght.Females.Rank = inStrengthF_rank, In.Strenght.Males = inStrengthM, In.Strength.Males.Rank = inStrengthM_rank, Out.Strength = outStrength, Out.Strength.Females = outStrengthF, Out.Strength.Females.Rank = outStrengthF_rank, Out.Strength.Males = outStrengthM_log, Out.Strength.Males.Rank = outStrengthM_rank_log, Eigenvector = egCent, Eigenvector.Females = egCentF, Eigenvector.Females.Rank = egCentF_rank, Eigenvector.Males = egCentM_log, Eigenvector.Males.Rank = egCentM_rank_log, Clustering = ccM, Clustering.Females = ccM_Females, Clustering.Females.Rank = ccM_Females_rank, Clustering.Males = ccM_Males, Clustering.Males.Rank = ccM_Males_rank)

x <- lapply(models, getR)
results <- do.call(rbind, x)
results <- results |>
  mutate(Metric.Sample = c("In-Degree", "In-Degree Females", "In-Degree Female Rank", "In-Degree Males", "In-Degree Males Rank", "Out-Degree", "Out-Degree Females", "Out-Degree Females Rank", "Out-Degree Males", "Out-Degree Males Rank", "In-Strength", "In-Strength Females", "In-Strength Females Rank", "In-Strength Males", "In-Strength Males Rank", "Out-Strength", "Out-Strength Females", "Out-Strength Females Rank", "Out-Strength Males", "Out-Strength Males Rank", "Eigenvector", "Eigenvector Females", "Eigenvector Females Rank", "Eigenvector Males", "Eigenvector Males Rank", "Clustering Coefficient", "Clustering Coefficient Females", "Clustering Coefficient Females Rank", "Clustering Coefficient Males", "Clustering Coefficient Males Rank"))
results

#Betweenness
modelB <- list(Betweenness = btM_glmm, Betweenness.Females = btM_Females_glmm, Betweenness.Females.Rank = btM_Females_rank_glmm, Betweenness.Males = btM_Males_glmm, Betweenness.Males.Rank = btM_Males_rank_glmm)
xB <- lapply(modelB, getRb)
resultsB <- do.call(rbind, xB)
resultsB <- resultsB |>
  mutate(Metric.Sample = c("Betweenness", "Betweenness Females", "Betweenness Females Rank", "Betweenness Males", "Betweenness Males Rank"))
resultsB
```

Table 2 of the original study provides the repeatability estimate (R), 95% confidence interval (CI), and the p-value of each repeatability estimate based on a node permutation test. The table below it summarizes the R and CI values returned by the models I ran

![](TablesFigures/Table2.png){fig-align="center" width="242"}

|                        |                 |       |        |
|------------------------|-----------------|-------|--------|
| **Metric**             | **Sample**      | **R** | **CI** |
| In-Degree              | All             |       |        |
| In-Degree              | Females         |       |        |
| In-Degree              | Females w/ Rank |       |        |
| In-Degree              | Males           |       |        |
| In-Degree              | Males w/ Rank   |       |        |
| Out-Degree             | All             |       |        |
| Out-Degree             | Females         |       |        |
| Out-Degree             | Females w/ Rank |       |        |
| Out-Degree             | Males           |       |        |
| Out-Degree             | Males w/ Rank   |       |        |
| In-Strength            | All             |       |        |
| In-Strength            | Females         |       |        |
| In-Strength            | Females w/ Rank |       |        |
| In-Strength            | Males           |       |        |
| In-Strength            | Males w/ rank   |       |        |
| Out-Strength           | All             |       |        |
| Out-Strength           | Females         |       |        |
| Out-Strength           | Females w/ Rank |       |        |
| Out-Strength           | Males           |       |        |
| Out-Strength           | Males w/ Rank   |       |        |
| Eigenvector Centrality | All             |       |        |
| Eigenvector Centrality | Females         |       |        |
| Eigenvector Centrality | Females w/ Rank |       |        |
| Eigenvector Centrality | Males           |       |        |
| Eigenvector Centrality | Males w/ Rank   |       |        |
| Clustering Coefficient | All             |       |        |
| Clustering Coefficient | Females         |       |        |
| Clustering Coefficient | Females w/ Rank |       |        |
| Clustering Coefficient | Males           |       |        |
| Clustering Coefficient | Males w/ Rank   |       |        |
| Betweenness            | All             |       |        |
| Betweenness            | Females         |       |        |
| Betweenness            | Females w/ Rank |       |        |
| Betweenness            | Males           |       |        |
| Betweenness            | Males w/ Rank   |       |        |

## 

## Node-Based Permuation

Since individual network metric are not independent of other network members, the orignal study used a node-based permutatio approach to tests for the significance of each repeatability estimate. Individual IDs were randomized for each of the three networks before running a new repeatability model. This was repeated 1000 times. I built the following function to do this easily for each metric. The first is for the standard node based permutation, the next is for the GLMMs used for betweenenss

```{r}
#| message: false
#| warning: false
nodePerm <- function(df, n, formula){
  permN <- do(n) * {
    permd <- df
    permd$ID = sample(permd$ID)
    m <- rpt(formula,
             grname = "ID",
             data = permd,
             datatype = "Gaussian")
    data.frame(R = m$R$ID)
  }
  return(permN)
}
nodePermGlmm <- function(df, n, formula){
  permN <- do(n) * {
    permd <- df
    permd$ID = sample(permd$ID)
    m <- rptPoisson(formula,
                    grname = "ID",
                    data = b)
    data.frame(R = m$R$ID)
  }
  return(permN)
}
```

### In-Degree & Out-Degree

```{r}
#| message: false
#| warning: false
#In-degree
inDegPerm <- nodePerm(df = allMetrics, n = 2, formula = In.Degree ~ (1|ID) + (1|Season))
inDegPval <- (sum(inDegPerm$R >= IOm$R) + 1) / (length(inDegPerm$R) + 1)

#In Degree Females
inDegPermF <- nodePerm(df = Females, n = 10, forumula = In.Degree ~ (1|ID) + (1|Season))
inDegPermF_pval <- (sum(inDegPermF$R >= IOmF$R) + 1) / (length(inDegPermF$R) + 1)

#In Degree Females w/ rank
inDegPermFrank <- nodePerm(df = Females, n = 10, forumula = In.Degree ~ rank + (1|ID) + (1|Season))
inDegPermFrank_pval <- (sum(inDegPermFrank$R >= IOmF_rank$R) + 1) / (length(inDegPermFrank$R) + 1)

#In Degree Males
inDegPermM <- nodePerm(df = Males, n = 10, forumula = In.Degree ~ (1|ID) + (1|Season))
inDegPermM_pval <- (sum(inDegPermM$R >= IOmM$R) + 1) / (length(inDegPermM$R) + 1)

#In Degree Males w/ rank
inDegPermMrank <- nodePerm(df = Males, n = 10, forumula = In.Degree ~ rank + (1|ID) + (1|Season))
inDegPermMrank_pval <- (sum(inDegPermMrank$R >= IOmM_rank$R) + 1) / (length(inDegPermMrank$R) + 1)

#Out degree
outDegPerm <- nodePerm(df = allMetrics, n = 2, formula = Out.Degree ~ (1|ID) + (1|Season))
inDegPval <- (sum(outDegPerm$R >= IOmOut$R) + 1) / (length(outDegPerm$R) + 1)

#Out degree females
outDegPermF <- nodePerm(df = Females, n = 2, formula = Out.Degree ~ (1|ID) + (1|Season))
outDegPermF_pval <- (sum(outDegPermF$R >= ioOutFemales$R) + 1) / (length(outDegPermF$R) + 1)

#Out degree females w/ rank
outDegPermFrank <- nodePerm(df = Females, n = 2, formula = Out.Degree ~ rank + (1|ID) + (1|Season))
outDegPermFrank_pval <- (sum(outDegPermFrank$R >= ioOutFemales_rank$R) + 1) / (length(outDegPermFrank$R) + 1)

#Out degree males
outDegPermM <- nodePerm(df = Males, n = 2, formula = Out.Degree ~ (1|ID) + (1|Season))
outDegPermM_pval <- (sum(outDegPermM$R >= ioOutMales$R) + 1) / (length(outDegPermM$R) + 1)

#Out degree males w/ rank
outDegPermMrank <- nodePerm(df = Males, n = 2, formula = Out.Degree ~ rank + (1|ID) + (1|Season))
outDegPermMrank_pval <- (sum(outDegPermMrank$R >= ioOutMales_rank$R) + 1) / (length(outDegPermMrank$R) + 1)
```

### In-Strength & Out-Strength

```{r}
#| message: false
#| warning: false
#In-strength
inStrengthPerm <- nodePerm(df = allMetrics, n = 2, formula = In.Strength ~ (1|ID) + (1|Season))
inStrengthPerm_pval <- (sum(inStrengthPerm$R >= inStrength$R) + 1) / (length(inStrengthPerm$R) + 1)

#In-strength females
inStrengthPermF <- nodePerm(df = Females, n = 2, formula = In.Strength ~ (1|ID) + (1|Season))
inStrengthPermF_pval <- (sum(inStrengthPermF$R >= inStrengthF$R) + 1) / (length(inStrengthPermF$R) + 1)

#In-strength females w/ rank
inStrengthPermFrank <- nodePerm(df = Females, n = 2, formula = In.Strength ~ rank + (1|ID) + (1|Season))
inStrengthPermFrank_pval <- (sum(inStrengthPermFrank$R >= inStrengthF_rank$R) + 1) / (length(inStrengthPermFrank$R) + 1)

#In-strength Males
inStrengthPermM <- nodePerm(df = Males, n = 2, formula = In.Strength ~ (1|ID) + (1|Season))
inStrengthPermM_pval <- (sum(inStrengthPermM$R >= inStrengthM$R) + 1) / (length(inStrengthPermM$R) + 1)

#In-strength Males w/ rank
inStrengthPermMrank <- nodePerm(df = Males, n = 2, formula = In.Strength ~ rank + (1|ID) + (1|Season))
inStrengthPermMrank_pval <- (sum(inStrengthPermMrank$R >= inStrengthM_rank$R) + 1) / (length(inStrengthPermMrank$R) + 1)

#Out-strength
outStrengthPerm <- nodePerm(df = allMetrics, n = 2, formula = Out.Strength ~ (1|ID) + (1|Season))
outStrengthPerm_pval <- (sum(outStrengthPerm$R >= outStrength$R) + 1) / (length(outStrengthPerm$R) + 1)

#out-strength females
outStrengthPermF <- nodePerm(df = Females, n = 2, formula = Out.Strength ~ (1|ID) + (1|Season))
outStrengthPermF_pval <- (sum(outStrengthPermF$R >= outStrengthF$R) + 1) / (length(outStrengthPermF$R) + 1)

#out-strength females w/ rank
outStrengthPermFrank <- nodePerm(df = Females, n = 2, formula = Out.Strength ~ rank + (1|ID) + (1|Season))
outStrengthPermFrank_pval <- (sum(outStrengthPermFrank$R >= outStrengthF_rank$R) + 1) / (length(outStrengthPermFrank$R) + 1)

#out-strength Males
outStrengthPermM <- nodePerm(df = Males, n = 2, formula = logOutStrength ~ (1|ID) + (1|Season))
outStrengthPermM_pval <- (sum(outStrengthPermM$R >= outStrengthM_log$R) + 1) / (length(outStrengthPermM$R) + 1)

#out-strength Males w/ rank
outStrengthPermMrank <- nodePerm(df = Males, n = 2, formula = logOutStrength ~ rank + (1|ID) + (1|Season))
outStrengthPermMrank_pval <- (sum(outStrengthPermMrank$R >= outStrengthM_rank_log$R) + 1) / (length(outStrengthPermMrank$R) + 1)
```

### Betweenness

```{r}
#| message: false
#| warning: false
#Betweenness
btPerm <- nodePermGlmm(df = allMetrics, n = 2, formula = b ~ (1|ID) + (1|Season))
btPerm_pval <- (sum(btPerm$R >= btM_glmm$R) + 1)/(length(btPerm$R) + 1)

#Female betweenness
btPermF <- nodePermGlmm(df = Females, n = 2, formula = b ~ (1|ID) + (1|Season))
btPermF_pval <- (sum(btPermF$R >= btM_Females_glmm$R) + 1)/(length(btPermF$R) + 1)

#Female betweenness w/ rank
btPermFrank <- nodePermGlmm(df = Females, n = 2, formula = b ~ rank + (1|ID) + (1|Season))
btPermFrank_pval <- (sum(btPermFrank$R >= btM_Females_rank_glmm$R) + 1)/(length(btPermF$R) + 1)

#Male betweenness
btPermM <- nodePermGlmm(df = Males, n = 2, formula = b ~ (1|ID) + (1|Season))
btPermM_pval <- (sum(btPermM$R >= btM_Males_glmm$R) + 1)/(length(btPermM$R) + 1)

#Male betweenness w/ rank
btPermMrank <- nodePermGlmm(df = Males, n = 2, formula = b ~ (1|ID) + (1|Season))
btPermMrank_pval <- (sum(btPermM$R >= btM_Males_glmm$R) + 1)/(length(btPermM$R) + 1)
```

### Eigenvctor Centrality

```{r}
#| message: false
#| warning: false
#Eigenvector
ecPerm <- nodePerm(df = allMetrics, n = 2, forumla = EC.vector ~ (1|ID) + (1|Season))
ecPerm_pval <- (sum(ecPerm$R >= egCent$R) + 1)/(length(ecPerm$R) + 1)

#Female eigenvector
ecPermF <- nodePerm(df = Females, n = 2, forumla = EC.vector ~ (1|ID) + (1|Season))
ecPermF_pval <- (sum(ecPermF$R >= egCentF$R) + 1)/(length(ecPermF$R) + 1)

#Female eigenvector w/ rank
ecPermFrank <- nodePerm(df = Females, n = 2, forumla = EC.vector ~ rank + (1|ID) + (1|Season))
ecPermFrank_pval <- (sum(ecPermFrank$R >= egCentF_rank$R) + 1)/(length(ecPermFrank$R) + 1)

#Male eigenvector
ecPermM <- nodePerm(df = Males, n = 2, forumla = logEC ~ (1|ID) + (1|Season))
ecPermM_pval <- (sum(ecPermM$R >= egCentM_log$R) + 1)/(length(ecPermM$R) + 1)

#Male eigenvector w/ rank
ecPermFrank <- nodePerm(df = Males, n = 2, forumla = logEC ~ rank + (1|ID) + (1|Season))
ecPermFrank_pval <- (sum(ecPermMrank$R >= egCentM_rank_log$R) + 1)/(length(ecPermMrank$R) + 1)
```

### Clustering Coefficient

```{r}
#| message: false
#| warning: false
#Clustering Coefficient
ccPerm <- nodePerm(df = allMetrics, n = 2, formula = CC ~ (1|ID) + (1|Season))
ccPerm_pval <- (sum(ccPerm$R >= ccM$R) + 1)/(length(ccPerm$R) + 1)

#Female CC
ccPermF <- nodePerm(df = Females, n = 2, formula = CC ~ (1|ID) + (1|Season))
ccPermF_pval <- (sum(ccPermF$R >= ccM_Females$R) + 1)/(length(ccPermF$R) + 1)

#Female CC w/ rank
ccPermFrank <- nodePerm(df = Females, n = 2, formula = CC ~ rank + (1|ID) + (1|Season))
ccPermFrank_pval <- (sum(ccPermFrank$R >= ccM_Females_rank$R) + 1)/(length(ccPermFrank$R) + 1)

#Male CC
ccPermM <- nodePerm(df = Males, n = 2, formula = CC ~ (1|ID) + (1|Season))
ccPermM_pval <- (sum(ccPermM$R >= ccM_Males$R) + 1)/(length(ccPermM$R) + 1)

#Male CC w/ rank
ccPermMrank <- nodePerm(df = Males, n = 2, formula = CC ~ rank + (1|ID) + (1|Season))
ccPermMrank_pval <- (sum(ccPermMrank$R >= ccM_Males_rank$R) + 1)/(length(ccPermMrank$R) + 1)
```

## Correlating Metrics

The study used Spearman rank correlations to assess for collinearity between each pair of network metrics. The results can be found in Table 1 of the original study.

```{r}
#| message: false
#| warning: false
network_metrics <- data.frame(In.Degree = allMetrics$In.Degree, Out.Degree = allMetrics$Out.Degree, In.Strength = allMetrics$In.Strength, Out.Strength = allMetrics$Out.Strength, Eigenvector = allMetrics$EC.vector, Cluster = allMetrics$CC, Between = allMetrics$b)
spearCor <- cor(network_metrics, method = "spearman")
spearCor
```

## Rank and Sex Models

In addition to the repeatability models, the study used (G)LMMs to investigate the effects of sex and rank differences on each of the 7 metrics.

For the sex models, "sex" was included as a fixed effect and ID and Season were again random effects. For the betweenness Poisson GLMM, an observational level random effect was included. After the models were run, node based permutation was run again for 1000 but with sex being randomized instead of ID.

For the rank models, males and females were analyzed separately and "rank" was a fixed effects with ID and Season as random effects. The rest of the analysis matched how the sex model was carried out. All mixed models were fit using functions in the {lme4} package.

Below are the functions needed to do the node based permutations. They have been adjusted slightly to account for the different analysis

```{r}
#| message: false
#| warning: false
#These two are for node based permutations for sex
nodePermSex <- function(df, n, formula){
  permN <- do(n) * {
    permd <- df
    permd$Sex = sample(permd$Sex)
    m <- lmer(formula,
             data = permd)
    coef_sex <- fixef(m)["SexM"]
    data.frame(perm_est = coef_sex)
  }
  return(permN)
}
nodePermGlmmSex <- function(df, n, formula){
  permN <- do(n) * {
    permd <- df
    permd$Sex = sample(permd$Sex)
    m <- glmer(formula,
                    data = permd,
            family = poisson)
    coef_sex <- fixef(m)["SexM"]
    data.frame(perm_est = coef_sex)
  }
  return(permN)
}
#These 2 are for node based permutations of rank based on differences in sex
nodePermRank <- function(df, n, formula){
  permN <- do(n) * {
    permd <- df
    permd$rank = sample(permd$rank)
    m <- lmer(formula,
             data = permd)
    coef_rank <- fixef(m)["rank"]
    data.frame(perm_est = coef_rank)
  }
  return(permN)
}
nodePermGlmmRank <- function(df, n, formula){
  permN <- do(n) * {
    permd <- df
    permd$rank = sample(permd$rank)
    m <- glmer(formula,
                    data = permd,
            family = poisson)
    coef_rank <- fixef(m)["rank"]
    data.frame(perm_est = coef_rank)
  }
  return(permN)
}
```

### Sex (G)LMMs

```{r}
#| message: false
#| warning: false
#sex as fixed effect
#In/Out Degree
inD_sex <- lmer(In.Degree ~ (1|ID) + (1|Season) + Sex,
                data = allMetrics)
summary(inD_sex)
est <- fixef(inD_sex)["SexM"]
p <- nodePermSex(allMetrics, n = 1000, formula = In.Degree ~ (1|ID) + (1|Season) + Sex)
inDp <- mean(abs(p$perm_est) >= abs(est))

outD_sex <- lmer(Out.Degree ~ (1|ID) + (1|Season) + Sex,
                 data = allMetrics)
summary(outD_sex)
est <- fixef(outD_sex)["SexM"]
p <- nodePermSex(allMetrics, n = 1000, formula = Out.Degree ~ (1|ID) + (1|Season) + Sex)
outDp <- mean(abs(p$perm_est) >= abs(est))
#In/Out Strength
inS_sex <- lmer(In.Strength ~ (1|ID) + (1|Season) + Sex,
                data = allMetrics)
summary(inS_sex)
est <- fixef(inS_sex)["SexM"]
p <- nodePermSex(allMetrics, n = 1000, formula = In.Strength ~ (1|ID) + (1|Season) + Sex)
inSp <- mean(abs(p$perm_est) >= abs(est))

outS_sex <- lmer(Out.Strength ~ (1|ID) + (1|Season) + Sex,
                 data = allMetrics)
summary(outS_sex)
est <- fixef(outS_sex)["SexM"]
p <- nodePermSex(allMetrics, n = 1000, formula = Out.Strength ~ (1|ID) + (1|Season) + Sex)
outSp <- mean(abs(p$perm_est) >= abs(est))
#Eigenvector Centrality
eg_sex <- lmer(EC.vector ~ (1|ID) + (1|Season) + Sex,
               data = allMetrics)
summary(eg_sex)
est <- fixef(eg_sex)["SexM"]
p <- nodePermSex(allMetrics, n = 1000, formula = EC.vector ~ (1|ID) + (1|Season) + Sex)
EGp <- mean(abs(p$perm_est) >= abs(est))
#Betweenness
allMetrics <- allMetrics |>
  mutate(observation.id = factor(1:nrow(allMetrics)))
bt_sex <- glmer(b ~ (1|ID) + (1|Season) + (1|observation.id) + Sex,
                data = allMetrics,
                family = poisson)
summary(bt_sex)
est <- fixef(bt_sex)["SexM"]
p <- nodePermGlmmSex(allMetrics, n = 1000, formula = b ~ (1|ID) + (1|Season) + Sex)
BTp <- mean(abs(p$perm_est) >= abs(est))
#Clustering Coefficient
cc_sex <- lmer(CC ~ (1|ID) + (1|Season) + Sex,
               data = allMetrics)
summary(cc_sex)
est <- fixef(cc_sex)["SexM"]
p <- nodePermSex(allMetrics, n = 1000, formula = CC ~ (1|ID) + (1|Season) + Sex)
CCp <- mean(abs(p$perm_est) >= abs(est))

print(paste("In-Degree p-value:", inDp, "; Out-Degree p-value:", outDp, "; In-Strength p-value:", inSp, "; Out-Strength p-value:", outSp, "; Eigenvector p-value:", EGp, "; Betweenness p-value:", BTp, "; Clustering Coefficient p-value:", CCp))
```

### Rank (G)LMMs

```{r}
#| message: false
#| warning: false
#Rank as fixed effect for Females
#In-Degree
inDF_rank <- lmer(In.Degree ~ (1|ID) + (1|Season) + rank,
                  data = Females)
summary(inDF_rank)
est <- fixef(inDF_rank)["rank"]
p <- nodePermRank(Females, n = 1000, formula = In.Degree ~ (1|ID) + (1|Season) + rank)
inDFrankp <- mean(abs(p$perm_est) >= abs(est))

#Out-Degree
outDF_rank <- lmer(Out.Degree ~ (1|ID) + (1|Season) + rank,
                   data = Females)
summary(outDF_rank)
est <- fixef(outDF_rank)["rank"]
p <- nodePermRank(Females, n = 1000, formula = Out.Degree ~ (1|ID) + (1|Season) + rank)
outDFrankp <- mean(abs(p$perm_est) >= abs(est))

#In-Strength
inSF_rank <- lmer(In.Strength ~ (1|ID) + (1|Season) + rank,
                  data = Females)
summary(inSF_rank)
est <- fixef(inSF_rank)["rank"]
p <- nodePermRank(Females, n = 1000, formula = In.Strength ~ (1|ID) + (1|Season) + rank)
inSFrankp <- mean(abs(p$perm_est) >= abs(est))

#Out-Strength
outSF_rank <- lmer(Out.Strength ~ (1|ID) + (1|Season) + rank,
                   data = Females)
summary(outSF_rank)
est <- fixef(outSF_rank)["rank"]
p <- nodePermRank(Females, n = 1000, formula = Out.Strength ~ (1|ID) + (1|Season) + rank)
outSFrankp <- mean(abs(p$perm_est) >= abs(est))

#Eigenvector
egF_rank <- lmer(EC.vector ~ (1|ID) + (1|Season) + rank,
                 data = Females)
summary(egF_rank)
est <- fixef(egF_rank)["rank"]
p <- nodePermRank(Females, n = 1000, formula = EC.vector ~ (1|ID) + (1|Season) + rank)
egFrankp <- mean(abs(p$perm_est) >= abs(est))

#Betweenness
Females <- Females |>
  mutate(observation.id = factor(1:nrow(Females)))
btF_rank <- glmer(b ~ (1|ID) + (1|Season) + (1|observation.id) + rank,
                  data = Females,
                  family = poisson)
summary(btF_rank)
est <- fixef(btF_rank)["rank"]
p <- nodePermGlmmRank(Females, n = 1000, formula = b ~ (1|ID) + (1|Season) + (1|observation.id) + rank)
btFrankp <- mean(abs(p$perm_est) >= abs(est))

#Clustering coefficient
ccF_rank <- lmer(CC ~ (1|ID) + (1|Season) + rank,
                 data = Females)
summary(ccF_rank)
est <- fixef(ccF_rank)["rank"]
p <- nodePermRank(Females, n = 1000, formula = CC ~ (1|ID) + (1|Season) + rank)
ccFrankp <- mean(abs(p$perm_est) >= abs(est))

print(paste("Female p-values: In-Degree p-value:", inDFrankp, "; Out-Degree p-value:", outDFrankp, "; In-Strength p-value:", inSFrankp, "; Out-Strength p-value:", outSFrankp, "; Eigenvector p-value:", egFrankp, "; Betweenness p-value:", btFrankp, "; Clustering Coefficient p-value:", ccFrankp))
#########################################################################################################################################################################################################################################################
#Rank as fixed effect males
#In-degree
inDM_rank <- lmer(In.Degree ~ (1|ID) + (1|Season) + rank,
                  data = Males)
summary(inDM_rank)
est <- fixef(inDM_rank)["rank"]
p <- nodePermRank(Males, n = 1000, formula = In.Degree ~ (1|ID) + (1|Season) + rank)
inDMp <- mean(abs(p$perm_est) >= abs(est))

#Out-degree
outDM_rank <- lmer(Out.Degree ~ (1|ID) + (1|Season) + rank,
                   data = Males)
summary(outDF_rank)
est <- fixef(outDM_rank)["rank"]
p <- nodePermRank(Males, n = 1000, formula = Out.Degree ~ (1|ID) + (1|Season) + rank)
outDMp <- mean(abs(p$perm_est) >= abs(est))

#In-Stength
inSM_rank <- lmer(In.Strength ~ (1|ID) + (1|Season) + rank,
                  data = Males)
summary(inSM_rank)
est <- fixef(inSM_rank)["rank"]
p <- nodePermRank(Males, n = 1000, formula = In.Strength ~ (1|ID) + (1|Season) + rank)
inSMp <- mean(abs(p$perm_est) >= abs(est))

#Out-Strength
outSM_rank <- lmer(Out.Strength ~ (1|ID) + (1|Season) + rank,
                   data = Males)
summary(outSM_rank)
est <- fixef(outSM_rank)["rank"]
p <- nodePermRank(Males, n = 1000, formula = Out.Strength ~ (1|ID) + (1|Season) + rank)
outSMp <- mean(abs(p$perm_est) >= abs(est))

#Eigenvector
egM_rank <- lmer(EC.vector ~ (1|ID) + (1|Season) + rank,
                 data = Males)
summary(egM_rank)
est <- fixef(egM_rank)["rank"]
p <- nodePermRank(Males, n = 1000, formula = EC.vector ~ (1|ID) + (1|Season) + rank)
egMrankp <- mean(abs(p$perm_est) >= abs(est))

#Betweenness
Males <- Males |>
  mutate(observation.id = factor(1:nrow(Males)))
btM_rank <- glmer(b ~ (1|ID) + (1|Season) + (1|observation.id) + rank,
                  data = Males,
                  family = poisson)
summary(btM_rank)
est <- fixef(btM_rank)["rank"]
p <- nodePermGlmmRank(Males, n = 1000, formula = b ~ (1|ID) + (1|Season) + (1|observation.id) + rank)
btMrankp <- mean(abs(p$perm_est) >= abs(est))

#Clustering coefficient
ccM_rank <- lmer(CC ~ (1|ID) + (1|Season) + rank,
                 data = Males)
summary(ccM_rank)
est <- fixef(ccM_rank)["rank"]
p <- nodePermRank(Males, n = 1000, formula = CC ~ (1|ID) + (1|Season) + rank)
ccMrankp <- mean(abs(p$perm_est) >= abs(est))

print(paste("Male p-values: In-Degree p-value:", inDMrankp, "; Out-Degree p-value:", outDMrankp, "; In-Strength p-value:", inSMrankp, "; Out-Strength p-value:", outSMrankp, "; Eigenvector p-value:", egMrankp, "; Betweenness p-value:", btMrankp, "; Clustering Coefficient p-value:", ccMrankp))
```

## Replication Successes

In replicating this study, I was able to (i) create social grooming networks for each of the three seasons, (ii) calculate the 7 metrics used, (iii) plot changes in these metrics over the three seasons and between sexes, (iv) calculate the repeatability of each metric across time using formulas in the {rptR} package.

## Replication Challenges
